file U:\ece_scratch\LFEV-ESCM\SCADA 2013\Touchscreen_Code\ScadaDisplay.4dg

file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\uLCD-43PT.fnc

000001  000001  #platform "uLCD-43PT"
000002  000001  #platform "uLCD-43PT"
000003  000008  */
000004  000009      #constant uLCD_43PT_GFX2
000005  000009      #constant uLCD_43PT_GFX2
000006  000010        
000007  000011      #IFNOT EXISTS PICASO_FUNCTIONS
file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\PicasoFunctions.fnc

000008  000012          #inherit "PicasoFunctions.fnc"        // inherit the generic functions
000009  000012          #inherit "PicasoFunctions.fnc"        // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PICASO_FUNCTIONS
000014  000004  #constant PICASO_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000017  #END
000019  000018        
000020  000019  #CONST
000021  000025  #END
000022  000026        
000023  000027        
000024  000028  #CONST
000025  000040  #END
000026  000041        
000027  000042        
000028  000043  #CONST
000029  000208  #END
000030  000209        
000031  000210        
000032  000211  // baud divisor rates for setbaud(n);
000033  000212  #CONST
000034  000234  #END
000035  000235        
000036  000236        
000037  000237        
000038  000238        
000039  000243  */
000040  000244        
000041  000245        
000042  000246  //==============================================//
000043  000247  // EVE bios functions                           //
000044  000248  //==============================================//
000045  000249                                                  //
000046  000250  func serin(), 1;                // read a byte from COM0
000047  000251  // Syntax: serin();
000048  000252  // Usage : char := serin();
000049  000253  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000254  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000255  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000256  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000257  //     : Returns: -1 if no character is available
000054  000258  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000259  //     : Returns: positive value 0 to 255 for a valid character received
000056  000260        
000057  000261  func putch("char"), 0;                // write single char to current output device
000058  000262  // Syntax: putch("char");
000059  000263  // Usage : putch("A");
000060  000264  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000265  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000266  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000267  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000268  //     : The arguments can be a variable, array element, expression or constant
000065  000269        
000066  000270  func serout("char"), 0;                // write a byte to COM0
000067  000271  // Syntax: serout1("char");
000068  000272  // Usage : serout1(ch);
000069  000273  // Notes : send character to COM1
000070  000274        
000071  000275  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000276  // Syntax: setbaud(baud_number);
000073  000277  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000278  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000279  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000280  //       : this is used as a table pointer to get the baud rate divisor
000077  000281  //       : value for one of the 20 selected baud rates, control is then
000078  000282  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000283  //       : The pre-defined constants equate to a value of 0-19.
000080  000284  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000285  //       : will occur.
000082  000286        
000083  000287  func to("device"), 1;                // output device redirection
000084  000288  // Syntax: to(outstream);
000085  000289  // Usage : to(APPEND); putstr("TWO ");
000086  000290  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000291  //     :
000088  000292  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000293  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000294  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000295  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000296  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000297  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000298  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000299  //     : sequential data to a media stream.
000096  000300  //     :
000097  000301  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000302  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000303  //     :                            appended to user memory if previous redirection was to an array.
000100  000304  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000305  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000306  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000307  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000308  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000309        
000106  000310        
000107  000311  func pause("milliseconds"), 0;            // blocking delay
000108  000312  // Syntax: pause(milliseconds);
000109  000313  // Usage : pause(1000);                //pause for 1 second
000110  000314  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000315        
000112  000316  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000317  // Syntax: putnum(format, value);
000114  000318  // Usage : var := putnum(HEX, val);
000115  000319  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000320  //     : Format: A constant that specifies the number format
000117  000321  //     : Value : The number to be printed
000118  000322  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000323  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000324  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000325  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000326  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000327  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000328  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000329  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000330  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000331  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000332  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000333  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000334  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000335  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000336  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000337  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000338  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000339  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000340  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000341  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000342  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000343  //     : | | | | V V V
000140  000344  //     : | | | | | | |
000141  000345  //     : | | | | | |
000142  000346  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000347  //     : | | | | digit count |
000144  000348  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000349  //     : | | | |
000146  000350  //     : | | | |
000147  000351  //     : | | | |
000148  000352  //     : | | | |
000149  000353  //     : | | | |
000150  000354  //     : | | | |______ 1 = leading zeros included
000151  000355  //     : | | | 0 = leading zeros suppressed
000152  000356  //     : | | |
000153  000357  //     : | | |
000154  000358  //     : | | |_______ 1 = leading zero blanking
000155  000359  //     : | |
000156  000360  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000361  //     : |
000158  000362  //     : |______ 1 = space before unsigned number
000159  000363        
000160  000364        
000161  000365  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000366        
000163  000367  func putstr("string"), 1;                       // print string to current output device
000164  000368  // Syntax: putstr(pointer);
000165  000369  // Usage : putstr("HELLO\n");
000166  000370  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000371  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000372  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000373  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000374  //       : using the to(...); function.
000171  000375  //       : A string constant is automatically terminated with a zero.
000172  000376  //       : A string in a data statement is not automatically terminated with a zero.
000173  000377  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000378  //       : element packs 1 or 2 characters.
000175  000379        
000176  000380        
000177  000381  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000382  // Syntax: strlen("varAddress);
000179  000383  // Usage : strlen("HELLO\n");
000180  000384  // Notes : gives the length of a string that is packed into regular var array
000181  000385  //       : Use str_Length(ptr)  for string pointer mode
000182  000386        
000183  000387        
000184  000388  //==============================================//
000185  000389  // Memory Access Function Prototypes            //
000186  000390  //==============================================//
000187  000391                                                  //
000188  000392  func peekW("address"), 1;                       // read a word from system memory
000189  000393  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000394  // refer to address map of internal variables   //
000191  000395  //==============================================//
000192  000396  // Math Functions                               //
000193  000397  //==============================================//
000194  000398                                                  //
000195  000399  func ABS("value"), 1;                           // return a positive number
000196  000400  // Syntax: ABS(value);
000197  000401  // Usage : var := ABS(arg);
000198  000402  // Notes : Returns the absolute value of an argument
000199  000403        
000200  000404  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000405  // Syntax: MIN(value1, value2);
000202  000406  // Usage : var := MIN(arg1, arg2);
000203  000407  // Notes : Returns the minimum of 2 arguments
000204  000408        
000205  000409  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000410  // Syntax: MAX(value1, value2);
000207  000411  // Usage : var := MAX(arg1, arg2);
000208  000412  // Notes : Returns the maximum of 2 arguments
000209  000413        
000210  000414  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000415  // Syntax: SWAP(&var1, &var2);
000212  000416  // Usage : SWAP(&var1, &var2);
000213  000417  // Notes : Swaps the contents of 2 variables or memory locations
000214  000418        
000215  000419  func SIN("angle"), 1;                           // return SIN of angle
000216  000420  // Syntax: SIN(angle);
000217  000421  // Usage : var := SIN(arg);
000218  000422  // Notes : Returns the sine in radians of an argument in degrees
000219  000423  //       : the returned value range is from 127 to -127. The real
000220  000424  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000425  //       : scaling must be done in user code.
000222  000426        
000223  000427  func COS("angle"), 1;                           // return COS of angle
000224  000428  // Syntax: COS(angle);
000225  000429  // Usage : var := COS(arg);
000226  000430  // Notes : Returns the cosine in radians of an argument in degrees
000227  000431  //       : the returned value range is from 127 to -127. The real
000228  000432  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000433  //       : scaling must be done in user code.
000230  000434        
000231  000435  func RAND(), 1;                                 // return a pseudo random number
000232  000436  // Syntax: RAND();
000233  000437  // Usage : var := RAND();
000234  000438  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000439  //       : The random number generator must first be seeded
000236  000440  //       : by using the SEED(number) function.
000237  000441        
000238  000442  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000443  // Syntax: SEED(number);
000240  000444  // Usage : SEED(arg);
000241  000445  // Notes : Seeds the random number generator.
000242  000446        
000243  000447  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000448  // Syntax: OVF();
000245  000449  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000450  //       : hiWord := OVF();
000247  000451  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000452        
000249  000453  func SQRT("number"), 1;                         // return square root of a number
000250  000454  // Syntax: SQRT(number);
000251  000455  // Usage : SQRT(arg);
000252  000456  // Notes : Returns the integer square root of a number.
000253  000457  //------------------------------------------------------------------//
000254  000458  //          Text Related Function Prototypes
000255  000459  //------------------------------------------------------------------//
000256  000460        
000257  000461  func txt_MoveCursor("line", "column"), 0;
000258  000462  // Syntax: txt_SetCursor(line, column);
000259  000463  // Usage : txt_SetCursor(arg1, arg2);
000260  000464  // Notes : Moves the text Cursor to a new screen position set by
000261  000465  //       : line,column parameters.
000262  000466        
000263  000467  func txt_Set("mode", "value"), 0;
000264  000468  // Syntax: txt_Set(mode, value);
000265  000469  // Usage : txt_Set(arg1, arg2);
000266  000470  // Returns : Original value before the change
000267  000471  // Notes : Sets various text related parameters used by other functions
000268  000472  //       : This allows the features to be set programatically with a
000269  000473  //       : single function call.It is strongly recommended to use the
000270  000474  //       : pre-defined constants rather than the mode numbers.
000271  000475  //       : NB:- Although it is often required to be able to set text
000272  000476  //       : functions with a single function call for graphics engine
000273  000477  //       : related functions, there is a complete set of single parameter
000274  000478  //       : shortcut functions that have exactly the same function as
000275  000479  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000480  //       :
000277  000481  //       : mode = TEXT_COLOUR (mode 0)
000278  000482  //       : txt_Set(TEXT_COLOUR, value);
000279  000483  //       : value = 0 to 0xFFFF, Black to White
000280  000484  //       : Sets the Text colour for the display
000281  000485  //       : Default = LIME.
000282  000486  //       :
000283  000487  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000488  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000489  //       : value = 0 to 0xFFFF, Black to White
000286  000490  //       : Sets the Text background colour for the display. Effective
000287  000491  //       : when text mode is Opaque.
000288  000492  //       : Default = BLACK.
000289  000493  //       :
000290  000494  //       : mode = FONT_ID (mode 2)
000291  000495  //       : txt_Set(FONT_ID, value);
000292  000496  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000497  //       : else this value is the name of a font included
000294  000498  //       : in a users program in a data statement.
000295  000499  //       : Default = FONT SIZE 3.
000296  000500  //       :
000297  000501  //       : mode = TEXT_WIDTH  (mode 3)
000298  000502  //       : txt_Set(TEXT_WIDTH, value);
000299  000503  //       : value = 1 to 16
000300  000504  //       : Sets the Text Width multiplier
000301  000505  //       : text will be printed magnified horizontally
000302  000506  //       : by this factor, Default = 1.
000303  000507  //       :
000304  000508  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000509  //       : txt_Set(TEXT_HEIGHT, value);
000306  000510  //       : value = 1 to 16
000307  000511  //       : Sets the Text Height multiplier
000308  000512  //       : text will be printed magnified vertically
000309  000513  //       : by this factor, Default = 1.
000310  000514  //       :
000311  000515  //       : mode = TEXT_XGAP  (mode 5)
000312  000516  //       : txt_Set(TEXT_XGAP, value);
000313  000517  //       : value = 1 to 32
000314  000518  //       : Sets the horizontal gap between characters
000315  000519  //       : The gap is in pixel units, Default = 0
000316  000520  //       :
000317  000521  //       : mode = TEXT_YGAP  (mode 6)
000318  000522  //       : txt_Set(TEXT_YGAP, value);
000319  000523  //       : value = 1 to 32
000320  000524  //       : Sets the vertical gap below characters
000321  000525  //       : The gap is in pixel units, Default = 0
000322  000526  //       :
000323  000527  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000528  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000529  //       : value = 0 to 255
000326  000530  //       : Sets the delay time (in ms) during character
000327  000531  //       : printing to give a 'teletype' like effect.
000328  000532  //       : Often used to attract attention to a string
000329  000533  //       : being printed which can often be missed if
000330  000534  //       : just suddenly appearing or changing.
000331  000535  //       : Default = 0 ms.
000332  000536  //       :
000333  000537  //       : mode = TEXT_OPACITY (mode 8)
000334  000538  //       : txt_Set(TEXT_OPACITY, value);
000335  000539  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000540  //       : value = OPAQUE (1) = Text Opaque
000337  000541  //       : Sets the Opacity/Transparency of the text
000338  000542  //       : Default = 0 or TRANSPARENT
000339  000543  //       :
000340  000544  //       : mode = TEXT_BOLD (mode 9)
000341  000545  //       : txt_Set(TEXT_BOLD, value);
000342  000546  //       : value = dont care
000343  000547  //       : Sets Bold Text mode for the next string or char
000344  000548  //       : The feature automatically resets after printing
000345  000549  //       : using putstr or print has completed
000346  000550  //       :
000347  000551  //       : mode = TEXT_ITALIC (mode 10)
000348  000552  //       : txt_Set(TEXT_ITALIC, value);
000349  000553  //       : value = dont care
000350  000554  //       : Sets Italic Text mode for the next string or char
000351  000555  //       : The feature automatically resets after printing
000352  000556  //       : using putstr or print has completed
000353  000557        
000354  000558  //       : mode = TEXT_INVERSE (mode 11)
000355  000559  //       : txt_Set(TEXT_INVERSE, value);
000356  000560  //       : value = dont care
000357  000561  //       : Sets Inverse Text mode for the next string or char
000358  000562  //       : The feature automatically resets after printing
000359  000563  //       : using putstr or print has completed
000360  000564  //       :
000361  000565  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000566  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000567  //       : value = dont care
000364  000568  //       : Sets Underlined Text mode for the next string or char
000365  000569  //       : The feature automatically resets after printing
000366  000570  //       : using putstr or print has completed
000367  000571  //       :
000368  000572  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000573  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000574  //       : value = bits are defined as:
000371  000575  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000576  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000577  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000578  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000579  //       : Allows a combination of text attributes to be defined together
000376  000580  //       : by 'or'ing the bits together.
000377  000581  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000582  //       : The feature automatically resets after printing
000379  000583  //       : using putstr or print has completed.
000380  000584  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000585  //       :
000382  000586  //       : mode = TEXT_WRAP (mode 14)
000383  000587  //       : txt_Set(TEXT_WRAP , value);
000384  000588  //       : Sets the position where text wrap will occur
000385  000589  //       : The feature automatically resets when screen
000386  000590  //       : mode is changed. If the value is set to 0,
000387  000591  //       : text wrap is turned off.
000388  000592  //       : of the current screen. Default value is 0
000389  000593  // Notes : The value is in pixel units.
000390  000594  //       :
000391  000595        
000392  000596  //       : txt_Set mode 15 reserved for future use
000393  000597  //       :
000394  000598        
000395  000599        
000396  000600        
000397  000601  //=====================================================//
000398  000602  // Single parameter short-cuts                         //
000399  000603  // for the txt_Set functions                           //
000400  000604  // These functions return the existing value before    //
000401  000605  // the change is made.                                 //
000402  000606  //=====================================================//
000403  000607  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000608  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000609  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000610  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000611  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000612  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000613  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000614  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000615  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000616  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000617  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000618  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000619  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000620  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000621  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000622  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000623        
000420  000624        
000421  000625  //------------------------------------------------------------------//
000422  000626  //                 Hardware Function Prototypes
000423  000627  //------------------------------------------------------------------//
000424  000628        
000425  000629  // I/O Pin reference:-
000426  000630  //
000427  000631  //    IO1_PIN           is pin 2 of J1
000428  000632  //    IO2_PIN           is pin 1 of J1
000429  000633  //    IO3_PIN           is pin 3 of J1
000430  000634  //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
000431  000635  //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
000432  000636  //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
000433  000637  //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
000434  000638  //    BUS_0             is pin 27 of J1
000435  000639  //    BUS_1             is pin 25 of J1
000436  000640  //    BUS_2             is pin 23 of J1
000437  000641  //    BUS_3             is pin 21 of J1
000438  000642  //    BUS_4             is pin 19 of J1
000439  000643  //    BUS_5             is pin 17 of J1
000440  000644  //    BUS_6             is pin 13 of J2
000441  000645  //    BUS_7             is pin 11 of J2
000442  000646  //    BACKLITE          is backlite control pin
000443  000647  //    AUDIO_ENABLE      is amplifier chip control pin
000444  000648        
000445  000649  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000446  000650  // Syntax: pin_Set(mode, pin);
000447  000651  // Usage : pin_Set(arg1, arg2);
000448  000652  // Notes : Sets the appropriate pins to Inputs or Outputs
000449  000653  //       : returns true if the pin number is legal (usually ignored)
000450  000654  //       :
000451  000655  //       : mode = 0 : Set Pin to Output
000452  000656  //       : pin_Set(0, pin);
000453  000657  //       : pin_Set(OUTPUT, pin);
000454  000658  //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
000455  000659  //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
000456  000660  //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
000457  000661  //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
000458  000662  //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
000459  000663  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000460  000664  //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
000461  000665  //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
000462  000666  //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
000463  000667  //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
000464  000668  //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
000465  000669  //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
000466  000670  //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
000467  000671  //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
000468  000672  //       : Sets the desired pin to be used as an Output.
000469  000673  //       :
000470  000674  //       : mode = 1 : Set Pin to Input
000471  000675  //       : pin_Set(1, pin);
000472  000676  //       : pin_Set(INPUT, pin);
000473  000677  //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
000474  000678  //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
000475  000679  //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
000476  000680  //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
000477  000681  //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
000478  000682  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000479  000683  //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
000480  000684  //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
000481  000685  //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
000482  000686  //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
000483  000687  //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
000484  000688  //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
000485  000689  //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
000486  000690  //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
000487  000691  //       : Sets the desired pin to be used as an Input.
000488  000692        
000489  000693  func pin_HI("pin"), 1;                    // set pin to logic '1'
000490  000694  // Syntax: pin_HI(pin);
000491  000695  // Usage : pin_HI(arg);
000492  000696  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000493  000697  //       : pin that was previously selected as an Output.
000494  000698  //       : returns true if the pin number is legal (usually ignored)
000495  000699  //       :
000496  000700  //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
000497  000701  //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
000498  000702  //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
000499  000703  //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
000500  000704  //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
000501  000705  //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
000502  000706  //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
000503  000707  //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
000504  000708  //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
000505  000709  //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
000506  000710  //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
000507  000711  //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
000508  000712  //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
000509  000713  //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
000510  000714  //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
000511  000715        
000512  000716  func pin_LO("pin"), 1;                    // set pin to logic '0'
000513  000717  // Syntax: pin_LO(pin);
000514  000718  // Usage : pin_LO(arg);
000515  000719  // Notes : Outputs a logic "Low" (0V) on the appropriate
000516  000720  //       : pin that was previously selected as an Output.
000517  000721  //       : returns true if the pin number is legal (usually ignored)
000518  000722  //       :
000519  000723  //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
000520  000724  //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
000521  000725  //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
000522  000726  //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
000523  000727  //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
000524  000728  //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
000525  000729  //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
000526  000730  //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
000527  000731  //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
000528  000732  //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
000529  000733  //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
000530  000734  //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
000531  000735  //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
000532  000736  //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
000533  000737  //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
000534  000738        
000535  000739  func pin_Read("pin"), 1;                // read pin, logic or analogue
000536  000740  // Syntax: pin_Read(pin);
000537  000741  // Usage : arg1 := pin_Read(arg2);
000538  000742  // Notes : Reads the logic state of the appropriate
000539  000743  //       : pin that was previously selected as an Input.
000540  000744  //       :
000541  000745  //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
000542  000746  //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
000543  000747  //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
000544  000748  //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
000545  000749  //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
000546  000750  //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
000547  000751  //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
000548  000752  //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
000549  000753  //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
000550  000754  //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
000551  000755  //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
000552  000756  //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
000553  000757  //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
000554  000758  //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
000555  000759  //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
000556  000760  //       : Returns a 0 (logic low) or 1 (logic high).
000557  000761        
000558  000762        
000559  000763  //------------------------------------------------------------------//
000560  000764  //                 P1 module BUS I/O control
000561  000765  //------------------------------------------------------------------//
000562  000766        
000563  000767  func bus_In(), 1;
000564  000768  // Syntax: bus_In();
000565  000769  // Usage : arg1 := bus_In();
000566  000770  // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
000567  000771  //       : The upper 8 bits of arg1 are set to 0.
000568  000772  //       : the BUS_RD and BUS_WR pins are not affected.
000569  000773  //       :
000570  000774  //       : BUS_0 is pin 27 of J1
000571  000775  //       : BUS_1 is pin 25 of J1
000572  000776  //       : BUS_2 is pin 23 of J1
000573  000777  //       : BUS_3 is pin 21 of J1
000574  000778  //       : BUS_4 is pin 19 of J1
000575  000779  //       : BUS_5 is pin 17 of J1
000576  000780  //       : BUS_6 is pin 13 of J2
000577  000781  //       : BUS_7 is pin 11 of J2
000578  000782        
000579  000783  func bus_Out("var"), 0;
000580  000784  // Syntax: bus_Out(var);
000581  000785  // Usage : bus_Out(arg1);
000582  000786  // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
000583  000787  //       : The upper 8 bits of arg1 are ignored.
000584  000788  //       : the BUS_RD and BUS_WR pins are not affected.
000585  000789  //       : NB:- any BUS pins that are set to inputs are not affected.
000586  000790  //       :
000587  000791  //       : BUS_0 is pin 27 of J1
000588  000792  //       : BUS_1 is pin 25 of J1
000589  000793  //       : BUS_2 is pin 23 of J1
000590  000794  //       : BUS_3 is pin 21 of J1
000591  000795  //       : BUS_4 is pin 19 of J1
000592  000796  //       : BUS_5 is pin 17 of J1
000593  000797  //       : BUS_6 is pin 13 of J2
000594  000798  //       : BUS_7 is pin 11 of J2
000595  000799        
000596  000800  func bus_Set("var"), 0;
000597  000801  // Syntax: bus_Set(var);
000598  000802  // Usage : bus_Set(arg1);
000599  000803  // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
000600  000804  //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
000601  000805  //       : The upper 8 bits of arg1 are ignored.
000602  000806  //       : the BUS_RD and BUS_WR pins are not affected.
000603  000807  //       :
000604  000808  //       : BUS_0 is pin 27 of J1
000605  000809  //       : BUS_1 is pin 25 of J1
000606  000810  //       : BUS_2 is pin 23 of J1
000607  000811  //       : BUS_3 is pin 21 of J1
000608  000812  //       : BUS_4 is pin 19 of J1
000609  000813  //       : BUS_5 is pin 17 of J1
000610  000814  //       : BUS_6 is pin 13 of J2
000611  000815  //       : BUS_7 is pin 11 of J2
000612  000816        
000613  000817  func bus_Write("var"), 0;
000614  000818  // Syntax: bus_Write(var);
000615  000819  // Usage : bus_Write(arg1);
000616  000820  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
000617  000821  //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
000618  000822  //       : LO for approx 50nsec then set back HI.
000619  000823  //       : The upper 8 bits of arg1 are ignored.
000620  000824  //       : NB:- the BUS_WR pin is automatically pre-set to an output to
000621  000825  //       : ensure BUS write integrity.
000622  000826  //       :
000623  000827  //       : BUS_0 is pin 27 of J1
000624  000828  //       : BUS_1 is pin 25 of J1
000625  000829  //       : BUS_2 is pin 23 of J1
000626  000830  //       : BUS_3 is pin 21 of J1
000627  000831  //       : BUS_4 is pin 19 of J1
000628  000832  //       : BUS_5 is pin 17 of J1
000629  000833  //       : BUS_6 is pin 13 of J2
000630  000834  //       : BUS_7 is pin 11 of J2
000631  000835        
000632  000836  func bus_Read(), 1;
000633  000837  // Syntax: bus_Read();
000634  000838  // Usage : arg1 := bus_Read();
000635  000839  // Notes : The BUS_RD pin set to LO, then, after a settling delay
000636  000840  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
000637  000841  //       : (the upper 8 bits being set to 0)
000638  000842  //       : the BUS_RD pin is then set back to a HI level.
000639  000843  //       : NB:- the BUS_RD pin is automatically pre-set to an output to
000640  000844  //       : ensure BUS write integrity.
000641  000845  //       :
000642  000846  //       : BUS_0 is pin 27 of J1
000643  000847  //       : BUS_1 is pin 25 of J1
000644  000848  //       : BUS_2 is pin 23 of J1
000645  000849  //       : BUS_3 is pin 21 of J1
000646  000850  //       : BUS_4 is pin 19 of J1
000647  000851  //       : BUS_5 is pin 17 of J1
000648  000852  //       : BUS_6 is pin 13 of J2
000649  000853  //       : BUS_7 is pin 11 of J2
000650  000854        
000651  000855        
000652  000856  //------------------------------------------------------------------//
000653  000857  //   Graphics Functions
000654  000858  //------------------------------------------------------------------//
000655  000859  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000656  000860  // Syntax: gfx_Set(mode, value);
000657  000861  // Usage : gfx_Set(arg1, arg2);
000658  000862  // Notes : Sets various graphics parameters used by other functions
000659  000863  //       : This allows the features to be set programatically with a
000660  000864  //       : single function call.It is strongly recommended to use the
000661  000865  //       : pre-defined constants rather than the mode numbers.
000662  000866  //       : NB:- Although it is often required to be able to set graphics
000663  000867  //       : functions with a single function call for graphics engine
000664  000868  //       : related functions, there is a complete set of single parameter
000665  000869  //       : shortcut functions that have exactly the same function as
000666  000870  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000667  000871  //       :
000668  000872  //       : mode = PEN_SIZE (mode 16)
000669  000873  //       : gfx_Set(PEN_SIZE, value);
000670  000874  //       : value = SOLID (value 0) rectangle and circle objects are solid
000671  000875  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000672  000876  //       : Sets the mode of the Pen used by most graphics objects
000673  000877  //       :
000674  000878  //       : mode = BACKGROUND_COLOUR (mode 17)
000675  000879  //       : gfx_Set(BACKGROUND_COLOUR, value);
000676  000880  //       : value = 0 to 0xFFFF, Black to White
000677  000881  //       : Sets the Background colour of the screen
000678  000882  //       :
000679  000883  //       : mode = OBJECT_COLOUR (mode 18)
000680  000884  //       : gfx_Set(OBJECT_COLOUR, value);
000681  000885  //       : value = 0 to 0xFFFF, Black to White
000682  000886  //       : Sets the Object colour used in various functions
000683  000887  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000684  000888  //       :
000685  000889  //       : mode = CLIPPING (mode 19)
000686  000890  //       : gfx_Set(CLIPPING, value);
000687  000891  //       : value = OFF (value 0) Clipping disabled
000688  000892  //       : value = ON (value 1) Clipping enabled
000689  000893  //       : Enables/Disables the Clipping feature
000690  000894  //       :
000691  000895  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000692  000896  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000693  000897  //       : value = 0 to 0xFFFF Black to White
000694  000898  //       : Sets Bitmap, Image or Animation Transparency Colour.
000695  000899  //       : NB not implemented
000696  000900  //       :
000697  000901  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000698  000902  //       : gfx_Set(5, value);
000699  000903  //       : value = OFF (value 0) Transparency disabled
000700  000904  //       : value = ON (value 1) Transparency enabled
000701  000905  //       : Enables/Disables the Transparency feature
000702  000906  //       : NB not implemented
000703  000907  //       :
000704  000908  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000705  000909  //       : gfx_Set(FRAME_DELAY, value);
000706  000910  //       : value = 0 to 65535 ms
000707  000911  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000708  000912  //       : over-ride the embedded frame delay of the clip. After the event,
000709  000913  //       : the setting will auto disable and if further inter-frame delays need
000710  000914  //       : overriding the setting must be re-issued.
000711  000915  //       :
000712  000916  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000713  000917  //       : gfx_Set(SCREEN_MODE, value);
000714  000918  //       : value = LANDSCAPE   (value 0)
000715  000919  //       : value = LANDSCAPE_R (value 1)
000716  000920  //       : value = PORTRAIT    (value 2)
000717  000921  //       : value = PORTRAIT_R  (value 3)
000718  000922  //       :
000719  000923  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000720  000924  //       : gfx_Set(OUTLINE_COLOUR, value);
000721  000925  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000722  000926  //       : Sets the filled Rectangle or Circle objects outline colour
000723  000927  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000724  000928  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000725  000929  //       :
000726  000930  //       : Only supports variable contrast for uOLED Modules
000727  000931  //       : mode = CONTRAST (mode 25) : Contrast
000728  000932  //       : gfx_Set(CONTRAST, value);
000729  000933  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000730  000934  //       : when contrast=0, display is placed in low power mode.
000731  000935  //       : This function should be called with contrast=0 when
000732  000936  //       : powering down the module.
000733  000937  //       :
000734  000938  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000735  000939  //       : gfx_Set(LINE_PATTERN, value);
000736  000940  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000737  000941  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000738  000942  //       : a value of 0 turns the feature off
000739  000943  //       :
000740  000944  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000741  000945  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000742  000946  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000743  000947  //       : NB not implemented, default is COLOUR16
000744  000948  //       :
000745  000949  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000746  000950  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000747  000951  //       : sets the button and slider objects bevel width
000748  000952  //       :
000749  000953  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000750  000954  //       : gfx_Set(BEVEL_SHADOW , 5);
000751  000955  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000752  000956  //       :
000753  000957  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000754  000958  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000755  000959  //       : sets the origin of drawn objects to a position other than 0,0
000756  000960  //       :
000757  000961  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000758  000962  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000759  000963  //       : sets the origin of drawn objects to a position other than 0,0
000760  000964        
000761  000965        
000762  000966  func gfx_Cls(), 0;                    // clear the screen
000763  000967  // Syntax: gfx_Cls();
000764  000968  // Usage : gfx_Cls();
000765  000969  // Notes : Clears the screen with current background colour
000766  000970        
000767  000971  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000768  000972  // Syntax: gfx_MoveTo(x, y);
000769  000973  // Usage : gfx_MoveTo(arg1, arg2);
000770  000974  // Notes : Moves the origin to a new x,y position
000771  000975        
000772  000976  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000773  000977  // Syntax: gfx_MoveRel(x, y);
000774  000978  // Usage : gfx_MoveRel(arg1, arg2);
000775  000979  // Notes : Moves the origin to a new x,y position
000776  000980  //       : relative to the current origing
000777  000981        
000778  000982  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000779  000983  // Syntax: gfx_LineTo(x1, y1);
000780  000984  // Usage : gfx_LineTo(arg1, arg2);
000781  000985  // Notes : Draws a Line from the origin x,y to x1,y1.
000782  000986  //       : The new origin is then set to x1, y1. Line colour needs
000783  000987  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000784  000988        
000785  000989  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000786  000990  // Syntax: gfx_LineRel(x1, y1);
000787  000991  // Usage : gfx_LineRel(arg1, arg2);
000788  000992  // Notes : Draws a Line from the origin x,y to x1,y1.
000789  000993  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000790  000994  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000791  000995        
000792  000996  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000793  000997  // Syntax: gfx_Line(x1, x2, y2, colr);
000794  000998  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000795  000999  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000796  001000        
000797  001001  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000798  001002  // Syntax: gfx_Line(x1, x2, y, colr);
000799  001003  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000800  001004  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000801  001005        
000802  001006  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000803  001007  // Syntax: gfx_Line(y1, y2, x, colr);
000804  001008  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000805  001009  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000806  001010        
000807  001011  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000808  001012  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000809  001013  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000810  001014  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000811  001015  //       : bottom corner (x2,y2) on the screen.
000812  001016        
000813  001017  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000814  001018  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000815  001019  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000816  001020  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000817  001021  //       : bottom corner (x2,y2) on the screen.
000818  001022        
000819  001023  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000820  001024  // Syntax: gfx_Circle(x, y, rad, colr);
000821  001025  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000822  001026  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000823  001027        
000824  001028  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000825  001029  // Syntax: gfx_Circle(x, y, rad, colr);
000826  001030  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000827  001031  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000828  001032        
000829  001033  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000830  001034  // Syntax: gfx_PutPixel(x, y, colr);
000831  001035  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000832  001036  // Notes : Plots a coloured pixel on the screen at x,y location
000833  001037        
000834  001038  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000835  001039  // Syntax: gfx_GetPixel(x, y);
000836  001040  // Usage : var := gfx_GetPixel(arg1, arg2);
000837  001041  // Notes : Reads and returns the colour value of a pixel at location x,y
000838  001042        
000839  001043  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000840  001044  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000841  001045  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000842  001046  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000843  001047  //       : Vertices must be specified in an anti-clockwise fashion
000844  001048        
000845  001049  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000846  001050  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000847  001051  // Usage : gfx_OrbitInit(&arg1, &arg2);
000848  001052  // Notes : Sets up the Orbit function parameters.
000849  001053  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000850  001054  //       : variables that get updated after calling gfx_Orbit(,,) function.
000851  001055  //       : The coordiantaes are calculated relative to the origin
000852  001056  //       : obtained by using the gfx_MoveTo(x, y) function.
000853  001057        
000854  001058  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000855  001059  // Syntax: gfx_Orbit(angle, distance);
000856  001060  // Usage : gfx_Orbit(arg1, arg2);
000857  001061  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000858  001062  //       : only known parameters are the angle and the distance from the current origin.
000859  001063        
000860  001064  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000861  001065  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000862  001066  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000863  001067  // Notes : This function is very similar to the Ploygon function
000864  001068  //       : with the exception of the 1st and the last vertices not joined.
000865  001069        
000866  001070  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000867  001071  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000868  001072  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000869  001073  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000870  001074  //       : Vertices must be minimum of 3 and can be specified in any fashion
000871  001075        
000872  001076  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000873  001077  // Syntax: gfx_Dot();
000874  001078  // Usage : gfx_Dot();
000875  001079  // Notes : Places a coloured dot at the origin
000876  001080        
000877  001081        
000878  001082  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000879  001083  // Syntax: gfx_Bullet();
000880  001084  // Usage : gfx_Bullet();
000881  001085  // Notes : Places a coloured circle at the origin
000882  001086  //       : filled or unfilled state is controlled by PenSize
000883  001087        
000884  001088  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000885  001089  // Syntax: gfx_IncX();
000886  001090  // Usage : var := gfx_IncX();
000887  001091  // Notes : Increments the x coordinate of the origin
000888  001092        
000889  001093  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000890  001094  // Syntax: gfx_IncY();
000891  001095  // Usage : var := gfx_IncY();
000892  001096  // Notes : Increments the y coordinate of the origin
000893  001097        
000894  001098  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000895  001099  // Syntax: gfx_BoxTo(x1, y1);
000896  001100  // Usage : gfx_BoxTo(arg1, arg2);
000897  001101  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000898  001102  //       : The new origin is then set to x1,y1. Rectangle colour needs
000899  001103  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000900  001104  //       : and the PenSize setting determines if Box is solid or outline.
000901  001105        
000902  001106  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000903  001107  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000904  001108  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000905  001109  // Notes : Specifies a clipping window region on the screen such that any objects
000906  001110  //       : and text placed onto the screen will be clipped and displayed only
000907  001111  //       : within that region. For the clipping window to take effect, "Clipping"
000908  001112  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000909  001113        
000910  001114        
000911  001115  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000912  001116  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000913  001117  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000914  001118  // *Notes:
000915  001119        
000916  001120  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000917  001121  // Syntax: gfx_SetClipRegion();
000918  001122  // Usage : var := gfx_SetClipRegion();
000919  001123  // *Notes:
000920  001124        
000921  001125  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000922  001126  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000923  001127  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000924  001128  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000925  001129  //       : with xradius = xrad and yradius = yrad.
000926  001130  //       : if PenSize = 0 Ellipse is Solid
000927  001131  //       : if PenSize = 1 Ellipse is Outline
000928  001132        
000929  001133        
000930  001134  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000931  001135  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000932  001136  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000933  001137  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000934  001138  //       : with xradius = xrad and yradius = yrad.
000935  001139        
000936  001140  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000937  001141  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000938  001142  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000939  001143  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000940  001144  //       : x,y arguments (top left corner). The size of the button depends on
000941  001145  //       : the font, width, height and length of the text.
000942  001146  //       : The button appearance will depend on the state parameter setting:
000943  001147  //       :         state = 0 : Button Pressed
000944  001148  //       :         state = 1 : Button Raised
000945  001149        
000946  001150  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000947  001151  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000948  001152  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000949  001153  // Notes : Draws a panel (groupbox) at screen location defined by
000950  001154  //       : x, y, width and height with colour "colour".
000951  001155  //       :         state = 0 : recessed
000952  001156  //       :         state = 1 : raised
000953  001157        
000954  001158  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000955  001159  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000956  001160  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000957  001161  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000958  001162  //       : Slider parameters are as follows:
000959  001163  //       :         mode = 0 : Slider recessed
000960  001164  //       :         mode = 1 : Slider raised
000961  001165  //       :         x1, y1 = top left corner
000962  001166  //       :         x2, y2 = bottom right corner
000963  001167  //       :         scale = n : sets the full scale range from 0 to n
000964  001168  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000965  001169  //       : returns:-
000966  001170        
000967  001171        
000968  001172  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000969  001173  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000970  001174  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000971  001175  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000972  001176  //       : and pastes it to another location determined by xd, yd.
000973  001177        
000974  001178  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000975  001179  // Syntax: gfx_RGBto565(red, green, blue);
000976  001180  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000977  001181  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000978  001182        
000979  001183  func gfx_332to565("COLOUR8BIT"), 1;
000980  001184  // Syntax: gfx_332to565(colour);
000981  001185  // Usage : gfx_332to565(arg);
000982  001186  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000983  001187        
000984  001188  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000985  001189  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000986  001190  // Usage : gfx_Selection(1, RED, YELLOW);
000987  001191  // Notes : Called prior to drawing a button, this function
000988  001192  //       : hilites the required text line on a multiline button.
000989  001193        
000990  001194  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000991  001195  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000992  001196  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000993  001197  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000994  001198  //       : Vertices must be specified in an anti-clockwise fashion
000995  001199        
000996  001200        
000997  001201  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000998  001202  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000999  001203  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
001000  001204  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001001  001205  //       : Vertices must be minimum of 3 and can be specified in any fashion
001002  001206        
001003  001207        
001004  001208  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
001005  001209  // Syntax: gfx_Offset(x, y);
001006  001210  // Usage : gfx_Offset(arg1, arg2);
001007  001211  // Notes : Set the screen offset
001008  001212        
001009  001213        
001010  001214        
001011  001215  func gfx_Get("mode"), 1;
001012  001216  // Syntax: gfx_Get(mode);
001013  001217  // Usage : arg1 := gfx_Get(arg);
001014  001218  // Notes : Returns various parameters to caller
001015  001219  //       :
001016  001220  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001017  001221  //       : var := gfx_Get(X_MAX);
001018  001222  //       : Returns the maximum horizontal value of the display
001019  001223  //       :
001020  001224  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001021  001225  //       : var := gfx_Get(Y_MAX);
001022  001226  //       : Returns the maximum vertical value of the display
001023  001227  //       :
001024  001228  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001025  001229  //       : var := gfx_Get(LEFT_POS);
001026  001230  //       : Returns the left location of the last drawn object
001027  001231  //       : such as a slider or button or an image/video
001028  001232  //       :
001029  001233  //       : mode = TOP_POS (mode 3) : Top location of Object
001030  001234  //       : var := gfx_Get(TOP_POS);
001031  001235  //       : Returns the top location of the last drawn object
001032  001236  //       : such as a slider or button or an image/video
001033  001237  //       :
001034  001238  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001035  001239  //       : var := gfx_Get(RIGHT_POS);
001036  001240  //       : Returns the right location of the last drawn object
001037  001241  //       : such as a slider or button or an image/video
001038  001242  //       :
001039  001243  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001040  001244  //       : var := gfx_Get(BOTTOM_POS );
001041  001245  //       : Returns the bottom location of the last drawn object
001042  001246  //       : such as a slider or button or an image/video
001043  001247  //       :
001044  001248        
001045  001249        
001046  001250  //==================================================//
001047  001251  // Single parameter short-cuts                      //
001048  001252  // for the gfx_Set functions                        //
001049  001253  // These functions return the existing value before //
001050  001254  // the change is made.                              //
001051  001255  //==================================================//
001052  001256  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001053  001257  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001054  001258  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001055  001259  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
001056  001260  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001057  001261  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001058  001262  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001059  001263  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001060  001264  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001061  001265  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001062  001266  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001063  001267  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001064  001268  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
001065  001269  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001066  001270  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001067  001271  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001068  001272        
001069  001273        
001070  001274  //==================================================//
001071  001275  // uSD/FLASH Function Prototypes                    //
001072  001276  //==================================================//
001073  001277  func media_Video("x", "y"), 0;                      // display movie at position x y
001074  001278  // Syntax: media_Video(x, y);
001075  001279  // Usage : media_Video(arg1, arg2);
001076  001280  // Notes : Play a Video/Animation clip from the uSD card at screen location
001077  001281  //       : specified by x,y (top left corner). The location of the clip in the
001078  001282  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001079  001283        
001080  001284  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001081  001285  // Syntax: media_VideoFrame(Frame_number);
001082  001286  // Usage : arg1 := media_VideoFrame();
001083  001287  // Notes : After a pointer to a valid video has been set with media_SetSector,
001084  001288  //       : calling this function shows each fram sequentially, returning
001085  001289  //       : the number of frames remaining. The position of the image is
001086  001290  //     : at the current origin as set with gfx_MoveTo(...);
001087  001291        
001088  001292  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001089  001293  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001090  001294  // Usage : media_SetAdd(arg1, arg2);
001091  001295  // Notes : Set uSD internal Address pointer for bytewise access
001092  001296        
001093  001297  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001094  001298  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001095  001299  // Usage : media_SetSector(arg1, arg2);
001096  001300  // Notes : Set uSD internal Sector pointer for sector block access
001097  001301        
001098  001302  func media_RdSector("*destination"), 1;
001099  001303  // Syntax: media_RdSector(*destination);
001100  001304  // Usage : media_RdSector(rdblock);
001101  001305  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001102  001306  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001103  001307  //       : After the read the Sector pointer is automatically incremented by 1.
001104  001308  //       : Returns TRUE if uSD response was TRUE
001105  001309        
001106  001310  func media_WrSector("*source"), 1;
001107  001311  // Syntax: media_WrSector(*source);
001108  001312  // Usage : media_WrSector(wrblock);
001109  001313  // Notes : Writes 512 bytes (256 words) from a source memory block
001110  001314  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001111  001315  //       : pointer is automatically incremented by 1.
001112  001316  //       : Returns TRUE if uSD response was TRUE
001113  001317        
001114  001318  func media_ReadByte(), 1;                // read a byte at the current stream position
001115  001319  // Syntax: media_RdByte();
001116  001320  // Usage : var := media_RdByte();
001117  001321  // Notes : Reads and Returns a single byte of data from the
001118  001322  //       : uSD card pointed to by the internal Address pointer.
001119  001323  //       : After the read the Address pointer is automatically
001120  001324  //       : incremented by 1.
001121  001325        
001122  001326  func media_ReadWord(), 1;                // read a word at the current stream position
001123  001327  // Syntax: media_ReadWord();
001124  001328  // Usage : var := media_ReadWord();
001125  001329  // *Notes : Reads and Returns a single word of data from the
001126  001330  //       : uSD card pointed to by the internal Address pointer.
001127  001331  //       : After the read the Address pointer is automatically
001128  001332  //       : incremented by 2.
001129  001333        
001130  001334  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
001131  001335  // Syntax: media_WriteByte(arg1);
001132  001336  // Usage : var := media_WriteByte(arg1);
001133  001337  // *Notes : Writes and Returns xxxxx
001134  001338  //       : After the write the Address pointer is automatically
001135  001339  //       : incremented by 1.
001136  001340        
001137  001341  func media_WriteWord("word"), 1;            // write a word to the current stream position
001138  001342  // Syntax: media_WriteWord(arg1);
001139  001343  // Usage : var := media_WriteWord(arg1);
001140  001344  // *Notes : Writes and Returns xxxxx
001141  001345  //       : After the write the Address pointer is automatically
001142  001346  //       : incremented by 2.
001143  001347        
001144  001348  func media_Image("x", "y"), 0;            // display image at position x y
001145  001349  // Syntax: media_Image(x, y);
001146  001350  // Usage : media_Image(arg1, arg2);
001147  001351  // Notes : Display an image from the uSD card at screen location
001148  001352  //       : specified by x,y (top left corner). The location of the
001149  001353  //       : Image in the uSD card must be specified by
001150  001354  //       : media_setSector(Image_Sector_Add) function.
001151  001355        
001152  001356  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001153  001357  // Syntax: media_Flush();
001154  001358  // Usage : var := media_Flush();
001155  001359  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001156  001360  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001157  001361        
001158  001362  func media_Init(), 1;                    // initialize uSD card
001159  001363  // Usage : media_Init();
001160  001364  // Notes : Initialise uSD CARD
001161  001365  //       : Response: 0 = No Card
001162  001366  //       :           1 = Card Initialised
001163  001367        
001164  001368        
001165  001369  //==============================================//
001166  001370  // Communications Function Prototypes           //
001167  001371  //==============================================//
001168  001372  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001169  001373  // Syntax: com_Init(buffer, bufsize, qualifier);
001170  001374  // Usage1: com_Init(mybuf, 20, 0);
001171  001375  // Usage2: com_Init(mybuf, 20, ':');
001172  001376  // Notes : initialize a serial capture buffer for the comms input
001173  001377  //       : The program must declare a var array as a circular buffer.
001174  001378  //       : Usage1 declares a circular buffer which will continually
001175  001379  //       : buffer characters.
001176  001380  //       : Usage2 must receive ':' before any characters will
001177  001381  //       : accumulate in the buffer.
001178  001382        
001179  001383  func com_Reset(), 0;                 // reset the comms receiver
001180  001384  // Syntax: com_Reset();
001181  001385  // Usage : com_Reset();
001182  001386  // Notes : reset comms to default polled mode
001183  001387        
001184  001388  func com_Count(), 1;                // return count of characters in receive buffer
001185  001389  // Syntax: com_Count();
001186  001390  // Usage : arg := com_Count();
001187  001391  // Notes : return count of buffered characters in buffer attachment
001188  001392        
001189  001393  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001190  001394  // Syntax: com_Full();
001191  001395  // Usage : if (com_Full() ,,,, go read buffer;
001192  001396  // Notes : return true if buffer full (not necessarily an error if
001193  001397  //       : buffer is sized to a packet size)
001194  001398        
001195  001399  func com_Error(), 1;                // return comms errors comms error occurred
001196  001400  // Syntax: com_Error();
001197  001401  // Usage : if (com_Error() ) ...... take recovery action;
001198  001402  // Notes : return non zero if any errors low level comms errors occured
001199  001403  // returns :
001200  001404  // bit0 = Receiver Overflow Error
001201  001405  // bit1 = Receiver Framing Error
001202  001406  // bit2 = Transmit Buffer Overflow
001203  001407        
001204  001408  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001205  001409  // Syntax: com_Sync();
001206  001410  // Usage : com_Sync();
001207  001411  // return true if sync character has been received in com_Init("...") mode
001208  001412        
001209  001413        
001210  001414  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001211  001415  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001212  001416  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001213  001417  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001214  001418  // Notes : initialize a serial buffer for the COM0 output.
001215  001419  //       : The program must declare a var array as a circular buffer.
001216  001420  //       : When a TX buffer is declared for comms, the transmission
001217  001421  //       : of characters becomes non blocking. The only time
001218  001422  //       : blocking will occur is if the buffer has insufficient space
001219  001423  //       : to accept the next character, in which case the function
001220  001424  //       : will wait for buffer space to become available. If the
001221  001425  //       : TX buffer is no longer required, just set the buffer pointer
001222  001426  //       : to zero, the size in this case doesnt matter and is ignored.
001223  001427  //       : The function can resize or reallocated to another buffer at
001224  001428  //       : any time. The buffer is flushed before any changes are made.
001225  001429  //       : "pin" designates an IO pin to control a bi-directional 
001226  001430  //       : control device for half duplex mode. "pin" will go HI at the
001227  001431  //       : start of a transmission, and will return low after the final
001228  001432  //       : byte is transmitted. If not required, just set "pin" to zero.
001229  001433        
001230  001434        
001231  001435  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001232  001436  // Syntax: com_TXcount();
001233  001437  // Usage : arg := com_Count();
001234  001438  // Notes : return count of characters remaining in COM0 transmit buffer
001235  001439  //       : that was previously allocated with com_TXbuffer(...);
001236  001440        
001237  001441        
001238  001442  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001239  001443  // Syntax: com_TXemptyEvent(function);
001240  001444  // Usage : arg := com_TXemptyEvent();
001241  001445  // Notes : If a comms TX buffer that was previously allocated with
001242  001446  //       : com_TXbuffer(...);, this function can be used to set up
001243  001447  //       : a function to be called when the COM0 TX buffer is empty.
001244  001448  //       : This is useful for either reloading the TX buffer, setting
001245  001449  //       : or clearing a pin to change the direction of eg a RS485
001246  001450  //       : line driver, or any other form of traffic control.
001247  001451  //       : The event function must not have any parameters.
001248  001452  //       : To disable the event, simply call com_TXemptyEvent(0).
001249  001453  //       : com_TXbuffer(...); also resets any active event.
001250  001454  //       : com_TXemptyEvent returns any previous event function
001251  001455  //       : address, or zero if there was no previous function.
001252  001456        
001253  001457        
001254  001458  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001255  001459  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001256  001460  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001257  001461  // Notes : Expecting that a comms TX buffer that was previously allocated with
001258  001462  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001259  001463  //       : the buffer being sent wile it is being loaded. Mormally, when
001260  001464  //       : using buffered comms, the transmit process will begin
001261  001465  //       : immediately. This is often undesirable for 2 reasons,
001262  001466  //       : 1] you may wish to build a packet then send it later
001263  001467  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001264  001468  //       : as the FIFO buffer is constantly trying to empty while
001265  001469  //       : you are busy tring to fill it.
001266  001470  // return -1 if function is called illegally when TX comms is not buffered.
001267  001471  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001268  001472  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001269  001473        
001270  001474        
001271  001475  //=============================================================//
001272  001476  // Auxilliary Communications Function Prototypes
001273  001477  //=============================================================//
001274  001478  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001275  001479  // Syntax: com_Init(buffer, bufsize, qualifier);
001276  001480  // Usage1: com_Init(mybuf, 20, 0);
001277  001481  // Usage2: com_Init(mybuf, 20, ':');
001278  001482  // Notes : initialize a serial capture buffer for the comms input
001279  001483  //       : The program must declare a var array as a circular buffer.
001280  001484  //       : Usage1 declares a circular buffer which will continually
001281  001485  //       : buffer characters.
001282  001486  //       : Usage2 must receive ':' before any characters will
001283  001487  //       : accumulate in the buffer.
001284  001488        
001285  001489  func com1_Reset(), 0;
001286  001490  // Syntax: com_Reset();
001287  001491  // Usage : com_Reset();
001288  001492  // Notes : reset comms receiver to default polled mode
001289  001493        
001290  001494  func com1_Count(), 1;
001291  001495  // Syntax: com_Count();
001292  001496  // Usage : arg := com_Count();
001293  001497  // Notes : return count of characters in receive buffer
001294  001498        
001295  001499  func com1_Full(), 1;
001296  001500  // Syntax: com_Full();
001297  001501  // Usage : if (com_Full() ,,,, go read buffer;
001298  001502  // Notes : return true if receive buffer full
001299  001503        
001300  001504  func com1_Error(), 1;
001301  001505  // Syntax: com_Error();
001302  001506  // Usage : if (com_Error() ) ...... take recovery action;
001303  001507  // Notes : return non zero if any level comms errors occured
001304  001508  // returns :
001305  001509  // bit0 = Receiver Overflow Error
001306  001510  // bit1 = Receiver Framing Error
001307  001511  // bit2 = Transmit Buffer Overflow
001308  001512        
001309  001513  func com1_Sync(), 1;
001310  001514  // Syntax: com_Sync();
001311  001515  // Usage : com_Sync();
001312  001516  // Notes : return true if sync character has been received in com_Init("...") mode
001313  001517        
001314  001518        
001315  001519  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001316  001520  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001317  001521  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001318  001522  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001319  001523  // Notes : initialize a serial buffer for the COM1 output.
001320  001524  //       : The program must declare a var array as a circular buffer.
001321  001525  //       : When a TX buffer is declared for comms, the transmission
001322  001526  //       : of characters becomes non blocking. The only time
001323  001527  //       : blocking will occur is if the buffer has insufficient space
001324  001528  //       : to accept the next character, in which case the function
001325  001529  //       : will wait for buffer space to become available. If the
001326  001530  //       : TX buffer is no longer required, just set the buffer pointer
001327  001531  //       : to zero, the size in this case doesnt matter and is ignored.
001328  001532  //       : The function can resize or reallocated to another buffer at
001329  001533  //       : any time. The buffer is flushed before any changes are made.
001330  001534  //       : "pin" designates an IO pin to control a bi-directional 
001331  001535  //       : control device for half duplex mode. "pin" will go HI at the
001332  001536  //       : start of a transmission, and will return low after the final
001333  001537  //       : byte is transmitted. If not required, just set "pin" to zero.
001334  001538        
001335  001539        
001336  001540  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001337  001541  // Syntax: com1_TXcount();
001338  001542  // Usage : arg := com1_Count();
001339  001543  // Notes : return count of characters remaining in COM1 transmit buffer
001340  001544  //       : that was previously allocated with com1_TXbuffer(...);
001341  001545        
001342  001546        
001343  001547  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001344  001548  // Syntax: com1_TXemptyEvent(function);
001345  001549  // Usage : arg := com1_TXemptyEvent();
001346  001550  // Notes : If a comms TX buffer that was previously allocated with
001347  001551  //       : com1_TXbuffer(...);, this function can be used to set up
001348  001552  //       : a function to be called when the COM1 TX buffer is empty.
001349  001553  //       : This is useful for either reloading the TX buffer, setting
001350  001554  //       : or clearing a pin to change the direction of eg a RS485
001351  001555  //       : line driver, or any other form of traffic control.
001352  001556  //       : The event function must not have any parameters.
001353  001557  //       : To disable the event, simply call com1_TXemptyEvent(0).
001354  001558  //       : com1_TXbuffer(...); also resets any active event.
001355  001559  //       : com1_TXemptyEvent returns any previous event function
001356  001560  //       : address, or zero if there was no previous function.
001357  001561        
001358  001562        
001359  001563  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001360  001564  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001361  001565  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001362  001566  // Notes : Expecting that a comms TX buffer that was previously allocated with
001363  001567  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001364  001568  //       : the buffer being sent wile it is being loaded. Mormally, when
001365  001569  //       : using buffered comms, the transmit process will begin
001366  001570  //       : immediately. This is often undesirable for 2 reasons,
001367  001571  //       : 1] you may wish to build a packet then send it later
001368  001572  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001369  001573  //       : as the FIFO buffer is constantly trying to empty while
001370  001574  //       : you are busy tring to fill it.
001371  001575  // return -1 if function is called illegally when TX comms is not buffered.
001372  001576  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001373  001577  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001374  001578        
001375  001579  func serin1(), 1;
001376  001580  // Syntax: serin1();
001377  001581  // Usage : char := serin1();
001378  001582  // Notes : return the next available character from COM1
001379  001583        
001380  001584  func serout1("char"), 0;
001381  001585  // Syntax: serout1("char");
001382  001586  // Usage : serout1(ch);
001383  001587  // Notes : send character to COM1
001384  001588        
001385  001589  func com_SetBaud("comport","baudrate/10"), 1;
001386  001590  // Syntax: com_SetBaud("comport","baudrate/10");
001387  001591  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001388  001592  // Notes : sets to any viable baud rate from 160 to 655350
001389  001593  // return true if baud rate was acceptable
001390  001594        
001391  001595        
001392  001596        
001393  001597  //==============================================//
001394  001598  // Display Access                               //
001395  001599  //==============================================//
001396  001600  func disp_Init("INIT_table", "GRAM_code"), 0;   // initialize display with required tables
001397  001601                                                  // NB not available on current Picaso GFX2
001398  001602        
001399  001603  func disp_SetReg("register", "data"), 0;
001400  001604  // Syntax: display_SetReg(register, data);
001401  001605  // Usage : display_SetReg(arg1, arg2);
001402  001606  // Notes : Sets uLCD specific display driver registers. Refer
001403  001607  //       : to appropriate display driver data sheet.
001404  001608        
001405  001609  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001406  001610  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001407  001611  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001408  001612  // Notes : Prepares the GRAM area for user access.
001409  001613  //       : Data can now be written with disp_GRAM.
001410  001614  //       : GRAM will be set accordingly for the correct screen mode.
001411  001615  //       : the LO word of the 32 bit pixel count is returned. This is
001412  001616  //       : usually all that is needed unlse GRAM area exceeds 256^2
001413  001617  //       : A copy of the 32bit value can be found in
001414  001618  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001415  001619        
001416  001620  func disp_WrGRAM("colour"), 0;
001417  001621  // Syntax: display_WrGRAM(colour);
001418  001622  // Usage : display_WrGRAM(arg);
001419  001623  // Notes : Data can be written to the GRAM consecutively using
001420  001624  //       : this function once the GRAM access window has been setup.
001421  001625        
001422  001626  func disp_WriteControl("value"), 0;             // write a control byte to the display
001423  001627  func disp_WriteWord("value"), 0;                // write a word to the display
001424  001628        
001425  001629        
001426  001630  func disp_ReadWord(), 1;                        // read a word from the display
001427  001631  // Syntax: disp_ReadWord();
001428  001632  // Usage : x:=disp_ReadWord();
001429  001633  // Notes : Read a word from the controller
001430  001634  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
001431  001635  //       : print(disp_ReadWord());        // print ID
001432  001636  //       : (Many displays are write only)
001433  001637        
001434  001638                                                  //
001435  001639  //==============================================//
001436  001640  // unadorned SPI functions                      //
001437  001641  //==============================================//
001438  001642  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001439  001643  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001440  001644  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001441  001645  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001442  001646                                                  //
001443  001647  //==============================================//
001444  001648  // flash device specific functions              //
001445  001649  //==============================================//
001446  001650  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001447  001651  func flash_ID(), 1;                             // read ID code from FLASH device
001448  001652  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001449  001653  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001450  001654                                                  //
001451  001655                                                  //
001452  001656  //==============================================//
001453  001657  // string and character size function           //
001454  001658  //==============================================//
001455  001659  func charwidth("char"), 1;                      // return width of a character in pixel units
001456  001660  func charheight("char"), 1;                     // return height of a character in pixel units
001457  001661  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001458  001662  func strheight(), 1;                            // return height of a string in pixel units
001459  001663        
001460  001664        
001461  001665  //------------------------------------------------------------------//
001462  001666  //        I2C Function Prototypes
001463  001667  //------------------------------------------------------------------//
001464  001668  func I2C_Open("speed"), 0;
001465  001669  // Syntax: I2C_Open(speed),
001466  001670  // Usage : I2C_Open(I2C_MED);
001467  001671  // Notes : configures the I2C module
001468  001672  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001469  001673        
001470  001674  func I2C_Close(), 0;
001471  001675  // Syntax: I2C_Close();
001472  001676  // Usage : I2C_Close();
001473  001677  // Notes : disables the I2C1 module.
001474  001678        
001475  001679  func I2C_Start(), 1;
001476  001680  // Syntax: I2C_Start();
001477  001681  // Usage : I2C_Start();
001478  001682  // Notes : generates a Start condition.
001479  001683  //       : returns true if successful (usually ignored)
001480  001684        
001481  001685  func I2C_Stop(), 1;
001482  001686  // Syntax: I2C_Stop();
001483  001687  // Usage : I2C_Stop();
001484  001688  // Notes : generates a Stop condition.
001485  001689  //       : returns true if successful (usually ignored)
001486  001690        
001487  001691  func I2C_Restart(), 1;
001488  001692  // Syntax: I2C_Restart();
001489  001693  // Usage : I2C_Restart();
001490  001694  // Notes : generates a Restart condition.
001491  001695  //       : returns true if successful (usually ignored)
001492  001696        
001493  001697  func I2C_Read(), 1;
001494  001698  // Syntax: I2C_Read();
001495  001699  // Usage : ch := I2C_Read();
001496  001700  // Notes : reads a single byte from the I2C Bus.
001497  001701        
001498  001702  func I2C_Write("byte"), 1;
001499  001703  // Syntax: I2C_Write(byte);
001500  001704  // Usage : r := I2C_Write(ch);
001501  001705  // Notes : is used to write a byte to the I2C bus.
001502  001706  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001503  001707        
001504  001708  func I2C_Ack(), 0;
001505  001709  // Syntax: I2C_Ack();
001506  001710  // Usage : I2C_Ack();
001507  001711  // Notes : generates the acknowledge condition.
001508  001712        
001509  001713  func I2C_Nack(), 0;
001510  001714  // Syntax: I2C_Nack();
001511  001715  // Usage : I2C_Nack();
001512  001716  // Notes : generates the negative acknowledge condition.
001513  001717        
001514  001718  func I2C_AckStatus(), 0;
001515  001719  // Syntax: I2C_AckStatus();
001516  001720  // Usage : r := I2C_AckStatus();
001517  001721  // Notes : returns the ACK status from the device.
001518  001722        
001519  001723  func I2C_AckPoll("control"), 1;
001520  001724  // Syntax: I2C_AckPoll();
001521  001725  // Usage : r := I2C_AckPoll(0xA0);
001522  001726  // Notes : waits for a device to return from ACK polling.
001523  001727        
001524  001728  func I2C_Idle(), 0;
001525  001729  // Syntax: I2C_Idle();
001526  001730  // Usage : I2C_Idle();
001527  001731  // Notes : waits until the I2C Bus is Inactive.
001528  001732        
001529  001733  func I2C_Gets("buffer", "size"), 1;
001530  001734  // Syntax: I2C_Gets("buffer", "size");
001531  001735  // Usage : r := I2C_Gets(mybuf, 16);
001532  001736  // Notes : only reads up to "size" characters into "buffer"
001533  001737  //       : Reads up to asciiz terminator including terminator
001534  001738        
001535  001739  func I2C_Getn("buffer", "size"), 1;
001536  001740  // Syntax: I2C_Gets("buffer", "size");
001537  001741  // Usage : r := I2C_Gets(mybuf, 16);
001538  001742  // Notes : reads "size" bytes into "buffer"
001539  001743  //       :
001540  001744        
001541  001745  func I2C_Puts("buffer"), 1;
001542  001746  // Syntax: I2C_Puts("buffer");
001543  001747  // Usage : r := I2C_Puts(mybuf);
001544  001748  // Notes : writes an asciiz string to the I2C device
001545  001749  //       : returns count of characters written
001546  001750        
001547  001751  func I2C_Putn("buffer", "count"), 1;
001548  001752  // Syntax: I2C_Putn("buffer","count");
001549  001753  // Usage : r := I2C_Puts(mybuf,10);
001550  001754  // Notes : writes up to "size" bytes to the I2C device
001551  001755  //       : returns number of bytes written
001552  001756        
001553  001757        
001554  001758  //------------------------------------------------------------------//
001555  001759  //        Image Control Function Prototypes
001556  001760  //------------------------------------------------------------------//
001557  001761  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001558  001762  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001559  001763  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001560  001764  // Notes : set the position where the image will be displayed
001561  001765  //       : returns true if index was ok and function was successful.
001562  001766  //       : you may turn off an image so when img_Refresh is called,
001563  001767  //       : the image will not be shown
001564  001768        
001565  001769  func img_Enable("handle", "index"), 1;
001566  001770  // Syntax: img_Enable(handle, index);
001567  001771  // Usage : r := img_Enable(hImageList, imagenum);
001568  001772  // Notes : enable image in a image list
001569  001773  //       : returns true if index was ok and function was successful.
001570  001774  //       : this is the default state so when img_Refresh is called,
001571  001775  //       : all the images in the list will be shown
001572  001776  //       : if index is set to -1, all of the images are enabled
001573  001777        
001574  001778  func img_Disable("handle", "index"), 1;
001575  001779  // Syntax: img_Disable(handle, index);
001576  001780  // Usage : r := img_Disable(hImageList, imagenum);
001577  001781  // Notes : disable image in a image list
001578  001782  //       : returns true if index was ok and function was successful.
001579  001783  //       : you must turn off an image so when img_Refresh is called,
001580  001784  //       : the image will not be shown.
001581  001785  //       : if index is set to -1, all of the images are disabled
001582  001786        
001583  001787        
001584  001788  func img_Darken("handle", "index"), 1;
001585  001789  // Syntax: img_Darken(handle, index);
001586  001790  // Usage : r := img_Darken(hImageList, imagenum);
001587  001791  // Notes : darken image in a image list
001588  001792  //       : returns true if index was ok and function was successful.
001589  001793  //       : if index is set to -1, all of the images are darkened
001590  001794  //       : NB:- this feature will only work for the next refresh, then
001591  001795  //       : the image reverts back to normal when displayed again.
001592  001796        
001593  001797        
001594  001798  func img_Lighten("handle", "index"), 1;
001595  001799  // Syntax: img_Lighten(handle, index);
001596  001800  // Usage : r := img_Lighten(hImageList, imagenum);
001597  001801  // Notes : lighten image in a image list
001598  001802  //       : returns true if index was ok and function was successful.
001599  001803  //       : if index is set to -1, all of the images are lightened
001600  001804  //       : NB:- this feature will only work for the next refresh, then
001601  001805  //       : the image reverts back to normal when displayed again.
001602  001806        
001603  001807  func img_SetWord("handle", "index", "offset", "word"), 1;
001604  001808  // Syntax: img_SetWord(handle, index, offset, word);
001605  001809  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001606  001810  // Notes : set specified word (0-7) in a image entry
001607  001811  //       : returns TRUE if successful, return value usually ignored.
001608  001812        
001609  001813  func img_GetWord("handle", "index", "offset"), 1;
001610  001814  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001611  001815  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001612  001816  // Notes : returns specified word (0-14) from an image entry
001613  001817  //       : refer to image control entry offsets.
001614  001818        
001615  001819  func img_Show("handle", "index"), 1;
001616  001820  // Syntax: img_Show(handle, index);
001617  001821  // Usage : display image entry (regardless of enable/disable)
001618  001822  //       : returns TRUE if successful, return value usually ignored.
001619  001823        
001620  001824  func img_SetAttributes("handle", "index","value"), 1;
001621  001825  // Syntax: img_SetAttributes("handle", "index","offset");
001622  001826  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001623  001827  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001624  001828  //       : of an image control entry. "value" refers to various bits in
001625  001829  //       : the image control entry (see image attribute flags).
001626  001830  //       : A '1' bit in the "value" field SETS the respective bit
001627  001831  //       : in the IMAGE_FLAGS field of the image control entry.
001628  001832  //       : returns TRUE if successful, return value usually ignored.
001629  001833        
001630  001834  func img_ClearAttributes("handle", "index","value"), 1;
001631  001835  // Syntax: img_ClearAttributes("handle", "index","offset");
001632  001836  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001633  001837  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001634  001838  //       : of an image control entry. "value" refers to various bits in
001635  001839  //       : the image control entry (see image attribute flags)
001636  001840  //       : a '1' bit in the "value" field CLEARS the respective bit
001637  001841  //       : in the IMAGE_FLAGS field of the image control entry.
001638  001842  //       : returns TRUE if successful, return value usually ignored.
001639  001843        
001640  001844  func img_Touched("handle", "index"), 1;
001641  001845  // Syntax: r := img_Touched(handle, index);
001642  001846  // Usage : img_Touched(hndl, 17);
001643  001847  //       : returns -1 if image not touched, or returns index
001644  001848  // Notes : if index is passed as -1, function tests all images,
001645  001849  //       : and returns -1 if image not touched, or returns index.
001646  001850        
001647  001851        
001648  001852        
001649  001853        
001650  001854  //------------------------------------------------------------------//
001651  001855  //        Timer Function Prototypes
001652  001856  //------------------------------------------------------------------//
001653  001857  func sys_T(), 1;
001654  001858  // Syntax: sys_T();
001655  001859  // Usage : t := sys_T();
001656  001860  // Notes : return the current value of the rolling system timer (1msec) LO word
001657  001861        
001658  001862  func sys_T_HI(), 1;
001659  001863  // Syntax: sys_T_HI();
001660  001864  // Usage : t := sys_T_HI();
001661  001865  // Notes : return the current value of the rolling system timer (1msec) HI word
001662  001866        
001663  001867  func sys_SetTimer("timernum","value"), 0;
001664  001868  // Syntax: sys_SetTimer("timernum", "value");
001665  001869  // Usage : sys_SetTimer(TIMER5, 10000);
001666  001870  // Notes : set a countdown on the selected timer, or 'top up' if required.
001667  001871  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001668  001872  //       : Maximum timeout period is 65.535 seconds
001669  001873  //       : A timer can be read with the sys_GetTimer("timernum") function
001670  001874        
001671  001875  func sys_GetTimer("timernum"), 1;
001672  001876  // Syntax: t := sys_GetTimer("timernum");
001673  001877  // Usage : t := sys_GetTimer(TIMER3);
001674  001878  // Notes : returns 0 if timer has expired, or the current countdown value.
001675  001879  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001676  001880  //       : Maximum timeout period is 65.535 seconds
001677  001881  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001678  001882        
001679  001883  func sys_SetTimerEvent("timernum","function"), 1;
001680  001884  // Syntax: sys_SetTimerFunction("timernum", "function");
001681  001885  // Usage : sys_SetTimer(TIMER5, myfunc);
001682  001886  // Notes : set a function to be called for selected timer.
001683  001887  //       : When the timer reaches zero, the function is called.
001684  001888  //       : The called function must not have any parameters
001685  001889  //       : sys_SetTimerEvent returns any previous event function
001686  001890  //       : address, or zero if there was no previous function.
001687  001891        
001688  001892  func sys_EventQueue(), 1;
001689  001893  // Syntax: sys_EventQueue();
001690  001894  // Usage : tasks := sys_EventQueue();
001691  001895  // Notes : returns the max number of events that were pending
001692  001896  //       : in the timer queue since the last call to this function.
001693  001897  //       : This can be used to assess timer event overhead burden,
001694  001898  //       : especially after or during a sys_EventsPostpone action.
001695  001899        
001696  001900  func sys_EventsPostpone(), 0;
001697  001901  // Syntax: sys_EventPostpone();
001698  001902  // Usage : sys_EventPostpone();   // postpone the event queue
001699  001903  // Notes : postpone any events until the sys_EventResume function is executed
001700  001904  //       : The timer event queue will continue to queue events, but no action
001701  001905  //       : will take place untill a sys_EventResume function is encountered.
001702  001906  //       : The queue will continue to receive up to 32 events before discarding
001703  001907  //       : any further events. This function is required to allow a sequence of
001704  001908  //       : instructions or functions to occur that would otherwise be corrupted
001705  001909  //       : by an event occuring during the sequence of instructions or functions.
001706  001910  //       : A good example of this is when you set a position to print, if there
001707  001911  //       : was no way of locking the current sequence, an event may occur which
001708  001912  //       : does a similar thing, and a contention would occur - printing to
001709  001913  //       : the wrong position. This function should be used wisely, if any action
001710  001914  //       : that is required would take considerable time, it is better to disable
001711  001915  //       : any conflicting event functions with a bypass flag, then restart the
001712  001916  //       : conflicting event by re-issuing a timer value.
001713  001917        
001714  001918  func sys_EventsResume(), 0;
001715  001919  // Syntax: sys_EventsResume();
001716  001920  // Usage : sys_EventsResume();   // resume the event queue
001717  001921  // Notes : resume any postponed events. The queue will try to execute any timer
001718  001922  //       : events that were incurred during the postponed period.
001719  001923        
001720  001924        
001721  001925  func sys_Sleep("units"), 1;
001722  001926  // Syntax: t := sys_Sleep("units");
001723  001927  // Usage : t := sys_Sleep(10);
001724  001928  // Notes : sets the display into low power mode for a period of time.
001725  001929  //       : Touching the touch screen will also wake from sleep.
001726  001930  //       : Returns remaining sleep units.
001727  001931        
001728  001932  func iterator("offset"), 0;
001729  001933  // Syntax: t :=  iterator("offset");
001730  001934  // Usage : t :=  iterator(10);
001731  001935  // Notes : set the iterator size for ++/--
001732  001936  //       : The next postinc,postdec,preinc of predec will alter
001733  001937  //       : by the specified value.
001734  001938  //       : The offset will return to 1 after the next operation.
001735  001939        
001736  001940        
001737  001941        
001738  001942        
001739  001943  //------------------------------------------------------------------//
001740  001944  //         Touch Screen Function Prototypes
001741  001945  //------------------------------------------------------------------//
001742  001946        
001743  001947  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001744  001948  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001745  001949  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001746  001950  // Notes : Specifies a new touch detect region on the screen
001747  001951  //       : such that only touch activity in that region will
001748  001952  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001749  001953        
001750  001954  func touch_Set("mode"), 0;
001751  001955  // Syntax: touch_Set(mode);
001752  001956  // Usage : touch_Set(arg);
001753  001957  // Notes : Sets various Touch Screen related parameters
001754  001958  //       :
001755  001959  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001756  001960  //       : touch_Set(TOUCH_ENABLE);
001757  001961  //       : Enables and initialises Touch Screen hardware
001758  001962  //       :
001759  001963  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001760  001964  //       : touch_Set(TOUCH_DISABLE );
001761  001965  //       : Disables the Touch Screen
001762  001966  //       : Note: Touch Screen runs in the background and disabling
001763  001967  //       : it when not in use will free up extra resources
001764  001968  //       : such as 4DVM CPU cycles.
001765  001969  //       :
001766  001970  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001767  001971  //       : touch_Set(TOUCH_REGIONDEFAULT);
001768  001972  //       : This will reset the current active region to default
001769  001973  //       : to the full screen without the application having to
001770  001974  //       : set a new active region for the full screen.
001771  001975  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001772  001976  //       : that requre to be interfaced with an external pointing
001773  001977  //       : device, values that are poked into TOUCH_DRIVE will be
001774  001978  //       : read with the touch_Get() function)
001775  001979        
001776  001980        
001777  001981  func touch_Get("mode"), 1;
001778  001982  // Syntax: touch_Get(mode);
001779  001983  // Usage : arg1 := touch_Get(arg);
001780  001984  // Notes : Returns various Touch Screen parameters to caller
001781  001985  //       :
001782  001986  //       : mode = TOUCH_STATUS  (mode 0)
001783  001987  //       : var := touch_Get(TOUCH_STATUS);
001784  001988  //       : Returns the various states of the touch screen
001785  001989  //       : 0 = NOTOUCH
001786  001990  //       : 1 = TOUCH_PRESSED
001787  001991  //       : 2 = TOUCH_RELEASED
001788  001992  //       : 3 = TOUCH_MOVING
001789  001993  //       :
001790  001994  //       : mode = TOUCH_GETX   (mode 1)
001791  001995  //       : var := touch_Get(TOUCH_GETX);
001792  001996  //       : Returns the X coordinates of the touch
001793  001997  //       :
001794  001998  //       : mode = TOUCH_GETY   (mode 2)
001795  001999  //       : var := touch_Get(TOUCH_GETY);
001796  002000  //       : Returns the Y coordinates of the touch
001797  002001        
001798  002002  //------------------------------------------------------------------//
001799  002003  //        CTYPE Function Prototypes
001800  002004  //------------------------------------------------------------------//
001801  002005        
001802  002006  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001803  002007  // Syntax: isdigit("char");
001804  002008  // Usage : Var := isdigit(ch);
001805  002009  // Notes : char specifies the ascii character for the test
001806  002010  //     : 0 : char is not an ascii digit.
001807  002011  //     : 1 : char is an ascii digit..
001808  002012  //     : Valid range is "0123456789"
001809  002013        
001810  002014  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001811  002015  // Syntax: isxdigit("char");
001812  002016  // Usage : Var := isxdigit(ch);
001813  002017  // Notes : char specifies the ascii character for the test
001814  002018  //     : 0 : char is not an ascii hexadecimal digit.
001815  002019  //     : 1 : char is an ascii hexadecimal digit..
001816  002020  //     : Valid range is "0123456789ABCDEF"
001817  002021        
001818  002022  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001819  002023  // Syntax: isupper("char");
001820  002024  // Usage : Var := isupper(ch);
001821  002025  // Notes : char specifies the ascii character for the test
001822  002026  //     : 0 : char is not an ascii upper-case letter.
001823  002027  //     : 1 : char is an ascii upper-case letter.
001824  002028  //     : Valid range is "ABCD....WXYZ"
001825  002029        
001826  002030  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001827  002031  // Syntax: islower("char");
001828  002032  // Usage : Var := islower(ch);
001829  002033  // Notes : char specifies the ascii character for the test
001830  002034  //     : 0 : char is not an ascii lower-case letter.
001831  002035  //     : 1 : char is an ascii lower-case letter.
001832  002036  //     : Valid range is "abcd....wxyz"
001833  002037        
001834  002038  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001835  002039  // Syntax: isalpha("char");
001836  002040  // Usage : Var := isalpha(ch);
001837  002041  // Notes : char specifies the ascii character for the test
001838  002042  //     : 0 : char is not an ascii lower or upper case letter.
001839  002043  //     : 1 : char is an ascii lower or upper case letter.
001840  002044  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001841  002045        
001842  002046  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001843  002047  // Syntax: isalnum("char");
001844  002048  // Usage : Var := isalnum(ch);
001845  002049  // Notes : char specifies the ascii character for the test
001846  002050  //     : 0 : char is not an ascii alphanumeric character.
001847  002051  //     : 1 : char is an ascii alphanumeric character.
001848  002052  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001849  002053        
001850  002054  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001851  002055  // Syntax: isprint("char");
001852  002056  // Usage : Var := isprint(ch);
001853  002057  // Notes : char specifies the ascii character for the test
001854  002058  //     : 0 : char is not a printable ascii character.
001855  002059  //     : 1 : char is a printable ascii character.
001856  002060  //     : Valid range is "0x20...0x7F"
001857  002061        
001858  002062  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001859  002063  // Syntax: isspace("char");
001860  002064  // Usage : Var := isspace(ch);
001861  002065  // Notes : char specifies the ascii character for the test
001862  002066  //     : 0 : char is not a space type character.
001863  002067  //     : 1 : char is a space type character.
001864  002068  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001865  002069        
001866  002070  //unformatted
001867  002071  func iswhite("char"), 1;    //
001868  002072  // Syntax: iswhite("char");
001869  002073  // Usage : Var := iswhite(ch);
001870  002074  // Notes : char specifies the ascii character for the test
001871  002075  //     : 0 : char is not a space or tab character.
001872  002076  //     : 1 : char is not a space or tab character.
001873  002077  //     : Valid range is space or tab
001874  002078        
001875  002079  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001876  002080  // Syntax: toupper("char");
001877  002081  // Usage : Var := toupper(ch);
001878  002082  // Notes : char specifies the ascii character for the test
001879  002083  //     : "ABCD....XYZ" : if character is a lower case letter.
001880  002084  //     : char : if character is not a lower case letter.
001881  002085  //     : Valid range is "abcd....wxyz"
001882  002086        
001883  002087  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001884  002088  // Syntax: tolower("char");
001885  002089  // Usage : Var := tolower(ch);
001886  002090  // Notes : char specifies the ascii character for the test
001887  002091  //     : "abcd....xyz" : if character is an upper case letter.
001888  002092  //     : char : if character is not an upper case letter.
001889  002093  //     : Valid range is "ABCD....WXYZ"
001890  002094        
001891  002095  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001892  002096  // Syntax: LObyte(var);
001893  002097  // Usage : myVar := LObyte(myvar2);
001894  002098  // Notes : var specifies the user variable
001895  002099  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001896  002100        
001897  002101  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001898  002102  // Syntax: HIbyte(var);
001899  002103  // Usage : myVar := HIbyte(myvar2);
001900  002104  // Notes : var specifies the user variable
001901  002105  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001902  002106        
001903  002107        
001904  002108  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001905  002109  // Syntax: ByteSwap(var);
001906  002110  // Usage : myVar := ByteSwap(myvar2);
001907  002111  // Notes : var specifies the user variable
001908  002112  //     : Returns the endian swapped value of a 16 bit variable
001909  002113        
001910  002114        
001911  002115  //------------------------------------------------------------------//
001912  002116  //        Memory Allocation Function Prototypes
001913  002117  //------------------------------------------------------------------//
001914  002118        
001915  002119  func mem_Alloc("size"), 1;
001916  002120  // Syntax: mem_Alloc(bytesize);
001917  002121  // Usage : myvar := mem_Alloc(100);
001918  002122  // Notes : Allocate a block of memory to pointer myvar
001919  002123  //       : The allocated memory contains garbage but is a fast allocation.
001920  002124  //       : The block must later be released with mem_Free();
001921  002125  //       : returns 0 if function fails
001922  002126        
001923  002127  func mem_AllocV("size"), 1;
001924  002128  // Syntax: mem_AllocV(bytesize);
001925  002129  // Usage : myvar := mem_AllocV(100);
001926  002130  // Notes : Allocate a block of memory to pointer myvar
001927  002131  //       : The block of memory is filled with signature values
001928  002132  //       : the block starts with A5,5A then fills with incrementing
001929  002133  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001930  002134  //       : This can be helpful when debugging
001931  002135  //       : The block must later be released with mem_Free();
001932  002136  //       : returns 0 if function fails
001933  002137        
001934  002138  func mem_AllocZ("size"), 1;
001935  002139  // Syntax: mem_AllocZ(bytesize);
001936  002140  // Usage : myvar := mem_AllocC(100);
001937  002141  // Notes : Allocate a zeroed block of memory to pointer myvar
001938  002142  //       : The block of memory is filled with zeroes
001939  002143  //       : The block must later be released with mem_Free();
001940  002144  //       : returns 0 if function fails
001941  002145        
001942  002146  func mem_Realloc("ptr", "size"), 1;
001943  002147  // Syntax: myvar := mem_Realloc("ptr", "size");
001944  002148  // Usage : myvar := mem_Realloc(ptr, size);
001945  002149  // Notes : The function may move the memory block to a new location,
001946  002150  //       : in which case the new location is returned.
001947  002151  //       : The content of the memory block is preserved up to the lesser
001948  002152  //       : of the new and old sizes, even if the block is moved.
001949  002153  //       : If the new size is larger, the value of the newly allocated
001950  002154  //       : portion is indeterminate. In case that ptr is NULL,
001951  002155  //       : the function behaves exactly as mem_Alloc, assigning a new block
001952  002156  //       : of size bytes and returning a pointer to the beginning of it.
001953  002157  //       : In case that the size is 0, the memory previously allocated in
001954  002158  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001955  002159  //       : pointer is returned.
001956  002160        
001957  002161  func mem_Free("allocation"), 1;
001958  002162  // Syntax: myvar := mem_Free(allocation);
001959  002163  // Usage : myvar := mem_Free(myvar);
001960  002164  // Notes : De-allocate a block of memory previously created with
001961  002165  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001962  002166  //       : returns 0 if function fails
001963  002167        
001964  002168  func mem_Heap(), 1;
001965  002169  // Syntax: myvar := mem_Heap();
001966  002170  // Usage : myvar := mem_Heap();
001967  002171  // Notes : returns bytecount available in heap
001968  002172  //       :
001969  002173        
001970  002174  func mem_Set("ptr","char","size"), 1;
001971  002175  // Syntax: mem_Set(ptr,char,bytesize);
001972  002176  // Usage : mem_Set(p, 'A', 100);
001973  002177  // Notes : fill a block of memory with a byte value
001974  002178  //       : returns ptr
001975  002179        
001976  002180  func mem_Copy("src", "dest", "bytecount"), 1;
001977  002181  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001978  002182  // Usage : myvar := mem_Copy(p1, p2, 100);
001979  002183  // Notes : copy a word aligned block of memory from src to dest
001980  002184  //       : Note that count is a byte count, this facilitates
001981  002185  //       : copying word aligned byte arrays when using word
001982  002186  //       : aliggned packed strings.
001983  002187  //       : returns src
001984  002188        
001985  002189  func mem_Compare("ptr1","ptr2","count"), 1;
001986  002190  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001987  002191  // Usage : myvar := mem_Compare(p1, p2, 100);
001988  002192  // Notes : compare blocks of memory at src, dest
001989  002193  //       : returns 0 if we have a match
001990  002194        
001991  002195  //------------------------------------------------------------------//
001992  002196  //        FAT16 Function Prototypes
001993  002197  //------------------------------------------------------------------//
001994  002198        
001995  002199  func file_Error(), 1;
001996  002200  // Syntax: myvar := file_Error();
001997  002201  // Usage : e := file_Error();
001998  002202  // Notes : return the most recent file error.
001999  002203  //       :
002000  002204        
002001  002205  func file_Count("filename"), 1;
002002  002206  // Syntax: count := file_Count("filename");
002003  002207  // Usage : count := file_Count("*.4dg");
002004  002208  // Notes : returns number of files found that match the criteria
002005  002209        
002006  002210  func file_Dir("filename"), 1;
002007  002211  // Syntax: count := file_Dir("filename");
002008  002212  // Usage : count := file_Dir("*.4dg");
002009  002213  // Notes : streams a string of filenames that agree with the search key
002010  002214  //       : returns number of files found that match the criteria
002011  002215        
002012  002216  func file_FindFirst("fname"), 1;
002013  002217  // Syntax: res := file_FindFirst("fname");
002014  002218  // Usage : if (file_FindFirst("*.4xe") ....
002015  002219  // Notes : returns true if at least 1 file exists
002016  002220  //       : that satisfies the file argument.
002017  002221  //       : Wildcards are usually used so if
002018  002222  //       : file_FindFirst returns true, further
002019  002223  //       : tests can be made using file_FindNext();
002020  002224  //       : to find all the files that match the
002021  002225  //       : wildcard class. Note that the stream behaviour
002022  002226  //       : is the same as file_Dir.
002023  002227  //       :
002024  002228        
002025  002229  func file_FindNext(), 1;
002026  002230  // Syntax: res := file_FindNext();
002027  002231  // Usage : while ((file_FindNext()) ....
002028  002232  // Notes : returns true if more file exists
002029  002233  //       : that satisfies the file argument
002030  002234  //       : that was given for  file_FindFirst.
002031  002235  //       : Wildcards must be used for
002032  002236  //       : file_FindFirst, else this function will
002033  002237  //       : always return zero as the only occurence
002034  002238  //       : will have already been found.
002035  002239  //       : Note that the stream behaviour
002036  002240  //       : is the same as file_Dir.
002037  002241  //       :
002038  002242        
002039  002243  func file_Exists("fname"), 1;
002040  002244  // Syntax: res := file_Exists("fname"),
002041  002245  // Usage : if(file_Exists("myfile") ....
002042  002246  // Notes : returns true if file exists
002043  002247  //       :
002044  002248        
002045  002249  func file_Open("fname", "mode"), 1;
002046  002250  // Syntax: handle := file_Open("fname","mode"),
002047  002251  // Usage : handle := file_Open("myfile.txt", 'r');
002048  002252  // Notes : returns handle if file exists
002049  002253  //       :
002050  002254        
002051  002255  func file_Close("handle"), 1;
002052  002256  // Syntax: res := file_Close("handle");
002053  002257  // Usage : res := file_Close(hnd1);
002054  002258  // Notes : returns true if file closed ok
002055  002259  //       :
002056  002260        
002057  002261  func file_Read("*dest", "size", "handle"), 1;
002058  002262  // Syntax: res := file_Read("*dest", "size", "handle"),
002059  002263  // Usage : res := file_Read(memblock,20,hnd1);
002060  002264  // Notes : returns number of characters read
002061  002265  //       : if "dest" is zero, data is read direct to GRAM window
002062  002266  //       :
002063  002267        
002064  002268        
002065  002269  func file_Seek("handle", "HiWord", "LoWord"), 1;
002066  002270  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
002067  002271  // Usage : res := file_Seek(hSource, 0, 0x1234);
002068  002272  // Notes : set file position to 0x00001234 (byte position 4660)
002069  002273  //       : for the file handle so subsequent data may be read
002070  002274  //       : from that position onwards with file_GetC(...),
002071  002275  //       : file_GetW(...) or file_GetS(...), or an image
002072  002276  //       : can be displayed with file_Image(...)
002073  002277  // Notes : returns true if ok, usually ignored
002074  002278        
002075  002279  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002076  002280  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002077  002281  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
002078  002282  // Notes : set file seek position to 123000
002079  002283  //       : for the file handle so subsequent data may be read
002080  002284  //       : from that record position onwards with file_GetC(...),
002081  002285  //       : file_GetW(...) or file_GetS(...), or an image
002082  002286  //       : can be displayed with file_Image(...)
002083  002287  // Notes : returns true if ok, usually ignored
002084  002288        
002085  002289  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
002086  002290  // Syntax: file_Tell("handle", &HiWord, &LoWord);
002087  002291  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
002088  002292  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
002089  002293  //       : returns true if function succeeded
002090  002294        
002091  002295  func file_Write("*source", "size", "handle"), 1;
002092  002296  // Syntax: res := fwrite("*source", "size", "handle"),
002093  002297  // Usage : res := fwrite(memblock, 20, hnd1);
002094  002298  // Notes : returns number of bytes written
002095  002299  //       :
002096  002300        
002097  002301  func file_Size("handle", "&HiWord", "&LoWord"), 1;
002098  002302  // Syntax: file_Size("handle", &HiWord, &LoWord);
002099  002303  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
002100  002304  // Notes : Reads the 32 bit file size and stores it into 2 variables.
002101  002305  //       : returns true if function succeeded
002102  002306        
002103  002307  func file_Image("x", "y", "handle"), 1;
002104  002308  // Syntax: file_Image(x, y, handle);
002105  002309  // Usage : file_Image(10, 10, hnd1);
002106  002310  // Notes : Display an image from a file at the current file position.
002107  002311  //       : The image is displayed at x,y (with respect to top left corner).
002108  002312  //       : If there is more than 1 image in the file, it can be
002109  002313  //       : accessed with file_Seek(...)
002110  002314        
002111  002315  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002112  002316  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002113  002317  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002114  002318  // Notes : Save a image from screen to file at the current file position.
002115  002319  //       : The image can later be displayed with file_Image(...);
002116  002320  //       : The file may be opened in append mode to accumulate multiple
002117  002321  //       : images. Later, the images can be accessed with file_Seek(...);
002118  002322  //       : Note that the image will be sector aligned.
002119  002323  //       : All image headers must start on a sector boundary.
002120  002324  //       : The image is saved from x, y (with respect to top left corner)
002121  002325  //       : and the capture area is determined by "width" and "height".
002122  002326  //       : returns 0 if function succeeded
002123  002327        
002124  002328  func file_PutC("char","handle"), 1;
002125  002329  // Syntax: file_PutC("char", "handle");
002126  002330  // Usage : file_PutC('x', hndl);
002127  002331  // Notes : returns true if function succeeded
002128  002332        
002129  002333  func file_GetC("handle"), 1;
002130  002334  // Syntax: file_GetC("handle");
002131  002335  // Usage : mychar := fgetC("handle");
002132  002336  // Notes : returns next char from file
002133  002337        
002134  002338  func file_PutW("word","handle"), 1;
002135  002339  // Syntax: file_PutW("word","handle");
002136  002340  // Usage : file_PutW(0x1234, hndl);
002137  002341  // Notes : returns true if function succeeded
002138  002342        
002139  002343  func file_GetW("handle"), 1;
002140  002344  // Syntax: file_GetW("handle");
002141  002345  // Usage : myword := fgetW("handle");
002142  002346  // Notes : returns next word in file
002143  002347        
002144  002348  func file_PutS("*source", "handle"), 1;
002145  002349  // Syntax: res := file_Puts("*source", "handle"),
002146  002350  // Usage : res := file_Puts(mystring, hnd1);
002147  002351  // Notes : returns number of characters written
002148  002352  //       :
002149  002353        
002150  002354  func file_GetS("*string", "size", "handle"), 1;
002151  002355  // Syntax: res := file_Gets("*string", "size", "handle");
002152  002356  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002153  002357  // Notes : get a string from a file
002154  002358  //       : returns pointer to string or null if failed.
002155  002359  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002156  002360  //       : NB:- only reads up to "size-1" characters into "string"
002157  002361  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002158  002362  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002159  002363  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002160  002364  //       : C] It reaches the end of file
002161  002365  //       : D] A read error occurs.
002162  002366        
002163  002367        
002164  002368  func file_Erase("fname"), 1;
002165  002369  // Syntax: res := file_Erase("fname");
002166  002370  // Usage : res := file_Erase("myfile.txt");
002167  002371  // Notes : returns true if successful
002168  002372  //       :
002169  002373        
002170  002374  func file_Rewind("handle"), 1;
002171  002375  // Syntax: res := file_Rewind("handle");
002172  002376  // Usage : res := file_Rewind(hnd1);
002173  002377  // Notes : returns true if file rewound ok (usually ignored)
002174  002378  //       : resets the file pointer the the beginning of the open file.
002175  002379        
002176  002380  func file_LoadFunction("fname.4xe"), 1;
002177  002381  // Syntax: res := file_LoadFunction("fname.4fn");
002178  002382  // Usage : myfunc := file_LoadFunction(myfuncname);
002179  002383  // Notes : Load a function or program from disk and
002180  002384  //       : return a function pointer to the allocation.
002181  002385  //       : The function can then be invoked just like any other
002182  002386  //       : function would be called via a function pointer.
002183  002387  //       : Parameters may be passed to it in a conventional way.
002184  002388  //       : The function may be discarded at any time when no
002185  002389  //       : longer required, thus freeing its memory resources.
002186  002390  //       : The loaded function can be discarded with mem_Free(..)
002187  002391  //       : eg:
002188  002392  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002189  002393  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002190  002394  //       : then elsewhere in your program:-
002191  002395  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002192  002396  //       : if(res == QUIT_APPLICATION) goto exitApp;
002193  002397  //       : Later in your program, when popupWindow is no longer
002194  002398  //       : required for the application:-
002195  002399  //       : res := mem_Free(popupWindow);
002196  002400  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002197  002401  //       : The callers stack is shared by the loaded function,
002198  002402  //       : however any global variables in the loaded function
002199  002403  //       : are private to that function.
002200  002404  //
002201  002405        
002202  002406  func file_Run("fname.4xe", "arglistptr"), 1;
002203  002407  // Syntax: res := file_Run("fname.4xe","arglistptr");
002204  002408  // Usage : res := file_Run(fname, argptr);
002205  002409  // Notes : current program releases any allocated memory but
002206  002410  //       : retains the stack and global memory.
002207  002411  //       : If arglistptr is 0, no arguments are passed, else
002208  002412  //       : arglist points to an array, the first element being
002209  002413  //       : the number of elements in the array.
002210  002414  //       : func 'main' in the called program accepts
002211  002415  //       : the arguments, if any. THe arguments can only
002212  002416  //       : be passed by value, no pointers or references can be
002213  002417  //       : used as all memory is cleared before the file
002214  002418  //       : is loaded. Refer to file_Exec and file_LoadFunction
002215  002419  //       : for functions that can pass by reference.
002216  002420        
002217  002421  func file_Exec("fname.4xe", "arglistptr"), 1;
002218  002422  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002219  002423  // Usage : res := file_Exec("fname.4xe","arglistptr");
002220  002424  // Notes : returns like a function, current program
002221  002425  //       : calling program is kept active and control returns to it.
002222  002426  //       : If arglistptr is 0, no arguments are passed, else
002223  002427  //       : arglist points to an array, the first element being
002224  002428  //       : the number of elements in the array.
002225  002429  //       : func 'main' in the called program accepts the arguments.
002226  002430  //       : This function is similar to file_LoadFunction(...), however,
002227  002431  //       : the function argument list is passed by pointer, and
002228  002432  //       : the memory consumed by the function is released as
002229  002433  //       : soon as the function completes.
002230  002434        
002231  002435  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002232  002436  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002233  002437  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002234  002438  // Notes : Reads a control file to create an image list.
002235  002439  //       : Returns NULL if function fails.
002236  002440  //       : Returns a handle (pointer to the memory allocation) to the
002237  002441  //       : image control list that has been created.
002238  002442  //       : "fname1" is the control list filename "*.dat"
002239  002443  //       : "fname2" is the image filename "*.gci"
002240  002444        
002241  002445  // Notes : This function Calculates the size of a chunk of memory required for
002242  002446  //       : a image list and populates it from the image control file ("*.dat")
002243  002447  //       : therefore, when imagelist is no longer required, you must de-allocate
002244  002448  //       : the image list memory by using eg:- mem_Free(hImagelist);
002245  002449  //       : to restore the heap.
002246  002450  //       :
002247  002451  //       : mode 0:- it is assumed that there is a graphics file with the
002248  002452  //       : file extension "fname2.gci". In this case, the images have been stored
002249  002453  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002250  002454  //       : "fname1.dat" file are saved in the image control so that the image control
002251  002455  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002252  002456  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002253  002457  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002254  002458  //       : for the file offsets and save them in the relevant entries in the image control.
002255  002459  //       : The penalty is that images take longer to find when displayed due to file_Seek
002256  002460  //       : overheads.
002257  002461  //
002258  002462  //       : mode 1:- it is assumed that there is a graphics file with the
002259  002463  //       : file extension "fname2.gci". In this case, the images have been stored
002260  002464  //       : in a FAT16 file concurrently, and the offset of the images are saved
002261  002465  //       : in the image control so that image file (*.gci) can be mapped to directly.
002262  002466  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002263  002467  //       : internally. This means that there is no seek time penalty, however, the
002264  002468  //       : image list takes a lot longer to build, as all the seeking is done at control
002265  002469  //       : build time.
002266  002470        
002267  002471  //       : mode 2:- the graphics file with the is placed in a partitioned area
002268  002472  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002269  002473  //       : disk, and the absolute address of the images are saved in the DAT file
002270  002474  //       : This is the fastest operation of the image control as there is no seeking
002271  002475  //       : or other disk activity taking place.
002272  002476        
002273  002477  func file_Mount(), 1;
002274  002478  // Syntax: r := file_Mount();
002275  002479  // Usage : r := file_Mount();
002276  002480  // Notes : Create a control block for FAT16 and mount the File System
002277  002481        
002278  002482  func file_Unmount(), 0;
002279  002483  // Syntax: file_Unmount();
002280  002484  // Usage : file_Unmount();
002281  002485  // Notes : release any control block and buffers for FAT16
002282  002486  //       : and unmount the File System
002283  002487        
002284  002488  func file_PlayWAV("fname1"), 1;
002285  002489  // Syntax: file_PlayWAV("fname1");
002286  002490  // Usage : file_PlayWAV("ding.wav");
002287  002491  // Notes : Play a wave file with filename "fname1"
002288  002492  //       : This function automatically grabs a chunk
002289  002493  //       : of memory for a file buffer, and a wave
002290  002494  //       : buffer. The minimum memory requirement is
002291  002495  //       : about 580 bytes for the disk io service and
002292  002496  //       : a minimum wave buffer size of 1024. The siz
002293  002497  //       : of the wave buffer allocation
002294  002498  //       : can be increased by the snd_BufSize function.
002295  002499  //       : The default size 1024 bytes.
002296  002500  //       : NB the memory is only required during the
002297  002501  //       : duration of play, and is automatically
002298  002502  //       : released while not in use.
002299  002503  //       : See the Sound Class services for other associated controls.
002300  002504  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002301  002505  //       : If errors occured, the folling is returned
002302  002506  //       : -6   : cant play this rate
002303  002507  //       : -5  : no data chunk found in first rsector
002304  002508  //       : -4  : no format data
002305  002509  //       : -3  : no wave chunk signature
002306  002510  //       : -2  : bad wave file format
002307  002511  //       : -1  : file not found
002308  002512        
002309  002513        
002310  002514        
002311  002515  //------------------------------------------------------------------//
002312  002516  //        Sound Class Services
002313  002517  //------------------------------------------------------------------//
002314  002518        
002315  002519  func snd_Volume("var"), 0;
002316  002520  // Syntax: snd_Volume("var");
002317  002521  // Usage : snd_Volume(30);
002318  002522  // Notes : set sound playback volume.  Var must
002319  002523  //       : be in the range from 8 (min volume)
002320  002524  //       : to 127 (max volume). If var is less
002321  002525  //       : than 8 volume is set to 8, and if
002322  002526  //       : var > 127 it is set to 127.
002323  002527        
002324  002528  func snd_Pitch("pitch"), 1;
002325  002529  // func snd_Pitch("freq"), 1;
002326  002530  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002327  002531  // Notes : sets the samples playback rate to a different frequency
002328  002532  //       : The minimum value is 4khz
002329  002533  //       : Setting the pitch to zero restores the original sample rate
002330  002534  //       : Return value is the samples original sample rate.
002331  002535        
002332  002536  func snd_BufSize("var"), 0;
002333  002537  // Syntax: snd_BufSize("var");
002334  002538  // Usage : snd_BufSize(2);
002335  002539  // Notes : specify the a memory chunk size for the wavefile buffer.
002336  002540  //       : default size 1024 bytes.
002337  002541  //       : 0 = 1024 bytes (default)
002338  002542  //       : 1 = 2048 bytes
002339  002543  //       : 2 = 4096 bytes
002340  002544  //       : 3 = 8192 bytes
002341  002545        
002342  002546  func snd_Stop(), 0;
002343  002547  // Syntax: snd_Stop();
002344  002548  // Usage : snd_Stop();
002345  002549  // Notes : stop any sound that is playing, releasing
002346  002550  //       : buffers and closes any open wav file.
002347  002551        
002348  002552  func snd_Pause(), 0;
002349  002553  // Syntax: snd_Pause();
002350  002554  // Usage : snd_Pause();
002351  002555  // Notes : pauses any sound that is playing, does nothing
002352  002556  //       : until sound is resumed with snd_Continue().
002353  002557  //       : The sample cam be terminated with snd_Stop.
002354  002558  //       : buffers and closes any open wav file.
002355  002559        
002356  002560  func snd_Continue(), 0;
002357  002561  // Syntax: snd_Continue();
002358  002562  // Usage : snd_Continue();
002359  002563  // Notes : resume any sound that is paused by snd_Pause.
002360  002564        
002361  002565  func snd_Playing(), 1;
002362  002566  // Syntax: snd_Playing();
002363  002567  // Usage : r := snd_Playing();
002364  002568  // Notes : returns 0 if sound has finished playing,
002365  002569  //       : else return number of 512 byte blocks to go.
002366  002570        
002367  002571        
002368  002572        
002369  002573  //------------------------------------------------------------------//
002370  002574  //        String Class Services
002371  002575  //------------------------------------------------------------------//
002372  002576        
002373  002577  func str_Ptr("&var"), 1;
002374  002578  // Syntax: str_Ptr(&var);
002375  002579  // Usage : p := str_Ptr(&var);
002376  002580  // Notes : return a byte pointer to a word region
002377  002581        
002378  002582  func str_GetD("&ptr", "&var"), 1;
002379  002583  // Syntax: str_GetD(&ptr, &var);
002380  002584  // Usage : ok := str_GetD(&ptr, &var);
002381  002585  // Notes : convert number in a string to DWORD ( myvar[2] )
002382  002586  //       : returns true if function succeeds, advancing ptr
002383  002587        
002384  002588  func str_GetW("&ptr", "&var"), 1;
002385  002589  // Syntax: str_GetW(&ptr, &var);
002386  002590  // Usage : ok := str_GetW(&ptr, &var);
002387  002591  // Notes : convert number in a string to WORD ( myvar )
002388  002592  //       : returns true if function succeeds, advancing ptr
002389  002593        
002390  002594  func str_GetHexW("&ptr", "&var"), 1;
002391  002595  // Syntax: str_GetHexW(&ptr, &var);
002392  002596  // Usage : ok := str_GetHexW(&ptr, &var);
002393  002597  // Notes : convert HEX number in a string to WORD ( myvar )
002394  002598  //       : returns true if function succeeds, advancing ptr
002395  002599        
002396  002600  func str_GetC("&ptr", "&var"), 1;
002397  002601  // Syntax: str_GetC(&ptr, &var);
002398  002602  // Usage : ok := str_GetC(&ptr, &var);
002399  002603  // Notes : get a valid ascii char in a string to WORD ( myvar )
002400  002604  //       : returns true if function succeeds, advancing ptr
002401  002605        
002402  002606  func str_GetByte("ptr"), 1;
002403  002607  // Syntax: str_GetByte(ptr);
002404  002608  // Usage : myvar := str_GetByte(ptr);
002405  002609  // Notes : get a byte to myvar
002406  002610  //       : returns value
002407  002611        
002408  002612  func str_GetWord("ptr"), 1;
002409  002613  // Syntax: GetWord(ptr);
002410  002614  // Usage : GetWord(ptr);
002411  002615  // Notes : get a word to myvar
002412  002616  //       : returns value
002413  002617        
002414  002618  func str_PutByte("ptr","val"), 0;
002415  002619  // Syntax: str_PutByte(ptr);
002416  002620  // Usage : myvar := str_PutByte(ptr);
002417  002621  // Notes : put a byte at ptr
002418  002622  //       : returns value
002419  002623        
002420  002624  func str_PutWord("ptr","val"), 0;
002421  002625  // Syntax: str_PutWord("ptr","val");
002422  002626  // Usage : str_PutWord(p,100);
002423  002627  // Notes : put word 100 at current pointer location
002424  002628  //       : returns value
002425  002629        
002426  002630  func str_Match("&ptr", "*str"), 1;
002427  002631  // Syntax: str_Match(&ptr, *str);
002428  002632  // Usage : r := str_Match(&p, "hello");
002429  002633  // Notes : Case sensitive match
002430  002634  //       : returns true if function succeded, andvancing pointer to position past
002431  002635  //       : the matched item. Note that any whitespace characters are skipped
002432  002636  //       : in the source string prior to the test.
002433  002637        
002434  002638  func str_MatchI("&ptr", "*str"), 1;
002435  002639  // Syntax: str_MatchI(&ptr, *str);
002436  002640  // Usage : r := str_MatchI(&p, "hello");
002437  002641  // Notes : Case insensitive match
002438  002642  //       : returns true if function succeded, andvancing pointer to position past
002439  002643  //       : the matched item. Note that any whitespace characters are skipped
002440  002644  //       : in the source string prior to the test.
002441  002645        
002442  002646  func str_Find("&ptr", "*str"), 1;
002443  002647  // Syntax: str_Find(&ptr, *str);
002444  002648  // Usage : n := str_Find(&p, "hello");
002445  002649  // Notes : given the address of a pointer to a source string as the
002446  002650  //       : first argument, and a pointer to a test string as the second
002447  002651  //       : argument, attempt to find the position of the matching string
002448  002652  //       : in the source string. The test is performed with case sensitivity.
002449  002653  //       : return 0 if not found, else returns the address of the first
002450  002654  //       : character of the match. NB:- The source pointer is not altered.
002451  002655        
002452  002656  func str_FindI("&ptr", "*str"), 1;
002453  002657  // Syntax: str_Find(&ptr, *str);
002454  002658  // Usage : n := str_Find(&p, "hello");
002455  002659  // Notes : given the address of a pointer to a source string as the
002456  002660  //       : first argument, and a pointer to a test string as the second
002457  002661  //       : argument, attempt to find the position of the matching string
002458  002662  //       : in the source string. The test is performed with no case
002459  002663  //       : sensitivity, eg upper and lower case chars are accepted.
002460  002664  //       : return 0 if not found, else returns the address of the first
002461  002665  //       : character of the match. NB:- The source pointer is not altered.
002462  002666        
002463  002667  func str_Length("ptr"), 1;
002464  002668  // Syntax: str_Length(ptr);
002465  002669  // Usage : len := str_Ptr(mystring);
002466  002670  // Notes : return the length of a byte aligned string excluding terminator
002467  002671        
002468  002672  func str_Printf("&ptr", "*format"), 1;
002469  002673  // Syntax: str_Printf("&ptr", "*format");
002470  002674  // Usage : r := str_Printf(&p, "hello");
002471  002675  // Notes : refer to documentation
002472  002676  //       :
002473  002677        
002474  002678  func str_Cat("dest","src"), 1;
002475  002679  // Syntax: str_Append("&dest","&src");
002476  002680  // Usage : str_Append(&buf,"Hello");
002477  002681  // Notes : Appends a copy of the source string to the destination string.
002478  002682  //       : The terminating null character in destination is overwritten by
002479  002683  //       : the first character of source, and a new null-character is appended
002480  002684  //       : at the end of the new string formed by the concatenation of both in destination.
002481  002685  //       : returns destination.
002482  002686        
002483  002687  func str_CatN("dest","src","count"), 1;
002484  002688  // Syntax: str_Append("&dest","&src","count");
002485  002689  // Usage : str_Append(&buf,"Monday",3);
002486  002690  // Notes : Appends a copy of the source string to the destination string.
002487  002691  //       : The number of characters copied is limited by "count".
002488  002692  //       : The terminating null character in destination is overwritten by
002489  002693  //       : the first character of source, and a new null-character is appended
002490  002694  //       : at the end of the new string formed by the concatenation of both in destination.
002491  002695  //       : returns destination.
002492  002696        
002493  002697        
002494  002698  func sys_StoreTouchCalibration(), 1;
002495  002699  // Syntax: sys_StoreTouchCalibration();
002496  002700  // Usage : r := sys_StoreTouchCalibration();
002497  002701  // Notes : Store the touch calibration values in non-volatile memory.
002498  002702  //       : Returns true if the values have been accepted and stored,
002499  002703  //       : else returns false if write could not be performed, or
002500  002704  //       : touch calibration values are improbable.
002501  002705  //       : The values that are stored are obtained from:-
002502  002706  //     : TOUCH_XMINCAL             78  // touch calibration value
002503  002707  //     : TOUCH_YMINCAL             79  // touch calibration value
002504  002708  //       : TOUCH_XMAXCAL             80  // touch calibration value
002505  002709  //       : TOUCH_YMAXCAL             81  // touch calibration value
002506  002710  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002507  002711  //       : This function is not supported on uVGA, Capicitive touch
002508  002712  //       : and 4.3" resistive touch modules.
002509  002713        
002510  002714        
002511  002715  func unicode_page("charbeg","charend","charoffset"), 1;
002512  002716  // Syntax: unicode_page("charbeg","charend","charoffset");
002513  002717  // Usage : eg:  F_Traditional_0x20_0xFF
002514  002718  // Notes : After selecting a unicode image control with txt_FontID,
002515  002719  //       : this function is called to set the required font within the
002516  002720  //       : unicode set. The file "Unicode.inc" contains wrappers for
002517  002721  //       : this function, and it is not normally called directly.
002518  002722  //       : Returns count of characters in the set.
002519  002723  //       : Refer to "Unicode.inc" for further information.
002520  002724        
002521  002725        
002522  002726  func EVE_SP(), 1;
002523  002727  // Syntax: EVE_SP();
002524  002728  // Usage : eg:  print(EVE_SP());
002525  002729  // Notes : Used for debugging to assess the current stack level,
002526  002730  //       : mainly for checking stack leaks
002527  002731        
002528  002732  func EVE_SSIZE(), 1;
002529  002733  // Syntax: EVE_SSIZE();
002530  002734  // Usage : eg:  print(EVE_SSIZE());
002531  002735  // Notes : Used to get the stack size,
002532  002736  //       : mainly for debugging purposes
002533  002737        
002534  002738        
002535  002739  // uVGAII extended functions
002536  002740  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002537  002741  // Syntax: disp_Sync(line);
002538  002742  // Usage : disp_Sync(480);
002539  002743  // Notes : Waits till the hardware gets to a certain line.
002540  002744  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002541  002745  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002542  002746  //       : depending on the graphics operation. The higher the value, the slower
002543  002747  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002544  002748  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002545  002749  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002546  002750  //       : be slowest (as its actually right at the end of the blanking period) and 508
002547  002751  //       : will cause a hangup situation as it is above the highes scanline value.
002548  002752  //       : Currently, this function is only supported on displays with SSD1963 driver.
002549  002753        
002550  002754        
002551  002755  // New functions added to PmmC v2.8
002552  002756  //================================================================
002553  002757  func CY(), 1;
002554  002758  // Syntax: CY();
002555  002759  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002556  002760  //       : print(myvar," "CY(),"\n");           // carry = 1
002557  002761  // Notes : This function returns the carry status of an
002558  002762  // unsigned overflow from any 16 or 32bit additions or sutractions.
002559  002763  //================================================================
002560  002764        
002561  002765        
002562  002766  //================================================================
002563  002767  func str_ByteMove("src", "dest", "count"), 1;
002564  002768  // func str_ByteMove("src", "dest", "count"), 1;
002565  002769  // Syntax   : str_ByteMove(src, dest, bytecount);
002566  002770  // Input    : STR *source points to byte aligned source.
002567  002771  //          : STR *dest   points to byte aligned destination.
002568  002772  //          : VAR count   number of bytes to transfer.
002569  002773  // Usage    : nextpos := str_ByteMove(s, d, 100);
002570  002774  // Notes    : copy bytes from "src" to "dest", stopping only
002571  002775  //          : when "count" is exhausted.
002572  002776  //          : No terminator is appended, it is purely a
002573  002777  //          : byte copy, and any zeroes encountered will
002574  002778  //          : also be copied.
002575  002779  // Returns  : returns a pointer to the end of the destination
002576  002780  //          : (which is "dest" + "count")
002577  002781  //================================================================
002578  002782        
002579  002783        
002580  002784  //================================================================
002581  002785  func str_Copy("dest", "src"), 1;
002582  002786  // Syntax   : str_Copy(dest, src);
002583  002787  // Input    : STR *dest   points to byte aligned destination.
002584  002788  //          : STR *source points to byte aligned source.
002585  002789  // Usage    : nextplace := str_Copy(d, s);
002586  002790  // Notes    : copy a string from "src" to "dest", stopping only
002587  002791  //          : when the end of source string "src" is encountered
002588  002792  //          : (0x00 terminator).
002589  002793  //          : The terminator is always appended, even if "src" is
002590  002794  //          : an empty string.
002591  002795  // Returns  : returns a pointer to the 0x00 string terminator at
002592  002796  //          : end of "dest" (which is "dest" + str_Length(src); )
002593  002797  //================================================================
002594  002798        
002595  002799  //================================================================
002596  002800  func str_CopyN("dest", "src", "count"), 1;
002597  002801  // Syntax   : str_CopyN(dest, src, bytecount);
002598  002802  // Input    : STR *dest   points to byte aligned destination.
002599  002803  //          : STR *source points to byte aligned source.
002600  002804  //          : VAR count   max number of chars to copy.
002601  002805  // Usage    : nextplace := str_CopyN(d, s, 100);
002602  002806  // Notes    : copy a string from "src" to "dest", stopping only
002603  002807  //          : when "count" is exhausted, or end of source
002604  002808  //          : string "str" is encountered (0x00 string terminator).
002605  002809  //          : The terminator is always appended, even if
002606  002810  //          : "count" is zero, or "src" is a null string.
002607  002811  // Returns  : returns a pointer to the 0x00 string terminator
002608  002812  //          : (which is "dest" + whatever was copied)
002609  002813  //================================================================
002610  002814        
002611  002815  //================================================================
002612  002816  func umul_1616("&res32", "val1", "val2"), 1;
002613  002817  // Syntax   : umul_1616(&res32, varA, varB);
002614  002818  // Input    : DWORD *result   points to 32bit result register.
002615  002819  //          : VAR   val1  16bit register or constant
002616  002820  //          : VAR   val2  16bit register or constant
002617  002821  // Usage    : var res32[2];
002618  002822  //          : umul_1616(&res32, myvar, 50000);
002619  002823  // Notes    : performs an unsigned multiply of 2 x 16bit values
002620  002824  //          : placing the 32bit result in a 2 word array.
002621  002825  // Returns  : the pointer to the 32bit result.
002622  002826  //          : carry and overflow are not affected.
002623  002827  //================================================================
002624  002828        
002625  002829  //================================================================
002626  002830  func uadd_3232("&res32", "&val1", "&val2"), 1;
002627  002831  // Syntax   : cmp_3232(&res32, &varA, &varB);
002628  002832  // Input    : DWORD *res32 points to optional result (or zero for compare)
002629  002833  //          : DWORD *val1 points to 32bit augend
002630  002834  //          : DWORD *val2 points to 32bit addend
002631  002835  // Usage    : var res32[2];
002632  002836  //          : res := cmp_3232(res32, val1, val2);
002633  002837  // Notes    : performs an unsigned addition of 2 x 32bit values
002634  002838  //          : placing the 32bit result in a 2 word array.
002635  002839  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002636  002840  //          ; carry flag is also set on 32bit unsigned overflow
002637  002841  //          ; and can be read with the CY() function.
002638  002842  //================================================================
002639  002843        
002640  002844  //================================================================
002641  002845  func usub_3232("&res32", "&val1", "&val2"), 1;
002642  002846  // Syntax   : cmp_3232(&res32, &varA, &varB);
002643  002847  // Input    : DWORD *res32 points to optional result (or zero for compare)
002644  002848  //          : DWORD *val1 points to first 32bit minuend
002645  002849  //          : DWORD *val2 points to 32bit subtrahend
002646  002850  // Usage    : var res32[2];
002647  002851  //          : res := cmp_3232(res32, val1, val2);
002648  002852  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002649  002853  //          : placing the 32bit result in a 2 word array.
002650  002854  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002651  002855  //          ; carry flag is also set on 32bit unsigned underflow
002652  002856  //          ; and can be read with the CY() function.
002653  002857  //================================================================
002654  002858        
002655  002859  //================================================================
002656  002860  func ucmp_3232("&val1", "&val2"), 1;
002657  002861  // Syntax   : cmp_3232(&varA, &varB);
002658  002862  // Input    : DWORD *val1 points to 32bit minuend
002659  002863  //          : DWORD *val2 points to 32bit sutrahend
002660  002864  // Usage    : res := cmp_3232(val1, val2);
002661  002865  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002662  002866  //          : The result of the subtraction is returned.
002663  002867  // Returns  : 0  if equal
002664  002868  //          : 1  if val1 > val2
002665  002869  //          : -1 if val1 < val2
002666  002870  //          : This function does not affect the carry flag.
002667  002871  //================================================================
002668  002872        
002669  002873  //------------------------------------------------------------------//
002670  002874  // CONSTANTS
002671  002875  //------------------------------------------------------------------//
002672  002876        
002673  002877  // generic constants
002674  002878  #CONST
002675  002887  #END
002676  002888        
002677  002889  //------------------------------------------------------------------------------
002678  002890  // Pin related constants
002679  002891  //------------------------------------------------------------------------------
002680  002892  #CONST
002681  002910  #END
002682  002911        
002683  002912  //------------------------------------------------------------------------------
002684  002913  //gfx_Set() related constants
002685  002914  //------------------------------------------------------------------------------
002686  002915  #CONST
002687  002932  #END
002688  002933        
002689  002934        
002690  002935  //gfx_Get() related constants
002691  002936  #CONST
002692  002945  #END
002693  002946        
002694  002947        
002695  002948        
002696  002949        
002697  002950  #CONST
002698  002963  #END
002699  002964        
002700  002965        
002701  002966  #CONST
002702  002989  #END
002703  002990        
002704  002991  //------------------------------------------------------------------------------
002705  002992  //txt_Set() related constants
002706  002993  //------------------------------------------------------------------------------
002707  002994  #CONST
002708  003013  #END
002709  003014        
002710  003015        
002711  003016        
002712  003017  //------------------------------------------------------------------------------
002713  003018  //txt_Set() related arguments
002714  003019  // NB:- FONT4 must be inherited if required,
002715  003020  // eg #inherit "FONT4.fnt"
002716  003021  //------------------------------------------------------------------------------
002717  003022  #CONST
002718  003034  #END
002719  003035        
002720  003036        
002721  003037        
002722  003038  //touch_Set() related constants
002723  003039  #CONST
002724  003043  #END
002725  003044        
002726  003045  //touch_Get() related constants
002727  003046  #CONST
002728  003054  #END
002729  003055        
002730  003056  // image control offset related constants
002731  003057  #CONST
002732  003064  #END
002733  003065        
002734  003066  // image attribute flags
002735  003067  // for img_SetAttributes(...) and img_ClearAttributes(...)
002736  003068  #CONST
002737  003082  #END
002738  003083        
002739  003084        
002740  003085  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002741  003085  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002742  003086        
002743  003087  // image control entry offsets
002744  003088  #CONST
002745  003103  #END
002746  003104        
002747  003105  #CONST
002748  003123  #END
002749  003124        
002750  003125        
002751  003126        
002752  003127        
002753  003128  #CONST
002754  003148  #END
002755  003149        
002756  003150        
002757  003151        
002758  003152  // timer control  related constants
002759  003153  #CONST
002760  003162  #END
002761  003163        
002762  003164  // I2C timing related constants
002763  003165  #CONST
002764  003169  #END
002765  003170        
002766  003171        
002767  003172  // spi_Init(...)  mode arguments
002768  003173  #CONST
002769  003183  #END
002770  003184        
002771  003185  //------------------------------------------------------------------------------
002772  003186  // system WORD variables accesible with peekW and pokeW or pointer access
002773  003187  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
002774  003188  // can also be accessed with peekW and pokeW
002775  003189  //------------------------------------------------------------------------------
002776  003190        
002777  003191  #CONST
002778  003283  #END
002779  003284        
002780  003285  //------------------------------------------------------------------------------
002781  003286  // FILEIO Error Code Constants
002782  003287  //------------------------------------------------------------------------------
002783  003288  #CONST
002784  003313  #END
002785  003314        
002786  003315  //==================================================================================================
002787  003316        
002788  003317        
002789  003318        
002790  000013      #ENDIF
002791  000014        
002792  000015        
002793  000016         #CONST
002794  000102      #END
002795  000103        
002796  000104  #constant TOUCH_DRIVE 78      // external pointing device control for gfx_Set(TOUCH_DRIVE, command);
002797  000104  #constant TOUCH_DRIVE 78      // external pointing device control for gfx_Set(TOUCH_DRIVE, command);
002798  000105        
002799  000106        
002800  000107        
002801  000108        
002802  000109        
002803  000110  //===========================================================================================
002804  000111        
002805  000112        
002806  000002        
002807  000003  // COM0 Rx 24, Tx 26
002808  000004        
002809  000005  // Program Skeleton 1.0 generated 10/13/2012 4:27:48 PM
002810  000006        
file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

002811  000007  #inherit "4DGL_16bitColours.fnc"
002812  000007  #inherit "4DGL_16bitColours.fnc"
002813  000004  */
002814  000005        
002815  000006        
002816  000007        
002817  000008  #CONST
002818  000149  #END
002819  000150        
002820  000008        
file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

002821  000009  #inherit "VisualConst.inc"
002822  000009  #inherit "VisualConst.inc"
002823  000001  // Line Patterns
002824  000002  #constant  LPCOARSE    0xF0F0
002825  000002  #constant  LPCOARSE    0xF0F0
002826  000003  #constant  LPMEDIUM    0x3333
002827  000003  #constant  LPMEDIUM    0x3333
002828  000004  #constant  LPFINE      0xAAAA
002829  000004  #constant  LPFINE      0xAAAA
002830  000005  #constant  LPDASHDOT   0x03CF
002831  000005  #constant  LPDASHDOT   0x03CF
002832  000006  #constant  LPDASHDOTDOT 0x0333
002833  000006  #constant  LPDASHDOTDOT 0x0333
002834  000007  #constant  LPSOLID     0x0000
002835  000007  #constant  LPSOLID     0x0000
002836  000010        
file U:\ece_scratch\LFEV-ESCM\SCADA 2013\Touchscreen_Code\ScadaDisplay.4DWork\ScadaDisplayConst.inc

002837  000011  #inherit "ScadaDisplayConst.inc"
002838  000011  #inherit "ScadaDisplayConst.inc"
002839  000001  // File generated 5/8/2013 11:52:25 AM
002840  000002  // Warning! This is a generated file, any manual changes will be
002841  000003  // lost during the next generation.
002842  000004        
002843  000005  // object indexes into ImageControl
002844  000006  #CONST
002845  000151  #END
002846  000152        
002847  000153  var disk, hndl ;
002848  000012        
file C:\Program Files\4D Labs\4D Workshop 4 IDE\include\ledDigitsDisplay.inc

002849  000013  #inherit "ledDigitsDisplay.inc"
002850  000013  #inherit "ledDigitsDisplay.inc"
002851  000001  // WARNING, this code will crash if newval exceeds maximum displayable number
002852  000002  func ledDigitsDisplay(var newval, var index, var left, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
002853  000003      var i, k, l, lb ;
002854  000004      l := 1 ;
002855  000005      for (i := 1; i < Digits; i++)
002856  000006          l *= 10 ;
002857  000007      next
002858  000008      lb := LeadingBlanks ;
002859  000009      for (i := 0; i < Digits; i++)
002860  000010          k := newval / l ;
002861  000011          newval -= k * l ;
002862  000012          if ( lb && (i < Digits - MinDigits) )
002863  000013              if (k == 0)
002864  000014                  k := -1 ; // was 10
002865  000015              else
002866  000016                  lb := 0 ;
002867  000017              endif
002868  000018          endif
002869  000019          l /= 10 ;
002870  000020          img_SetWord(hndl, index, IMAGE_INDEX, k);
002871  000021          img_SetWord(hndl, index, IMAGE_XPOS, left+i*WidthDigit) ;
002872  000022          img_Show(hndl, index);
002873  000023      next
002874  000024  endfunc
002875  000025        
002876  000014        
002877  000015  //#inherit "THERMOMETERConst.inc"
002878  000016        
002879  000017        
002880  000018  var configHndl;
002881  000019  var configFile:= "CONFIG.txt";
002882  000020  var dataFile:="SDATA.txt";
002883  000021  var dataHndl;
002884  000022        
002885  000023        
002886  000024  // SYSTEM VARIABLES ----------------
002887  000025        
002888  000026  // diagnostic mode main menu
002889  000027  var ReadyToDrive:=0;
002890  000028  var SafetyLoopState:=0;
002891  000029  var SafetyLoopOut:=0;
002892  000030  var BMSConnection:=0;
002893  000031  var MotorContConnection:=1;
002894  000032  var subSystemBool:=0;
002895  000033  var LC_ON:=0;
002896  000034        
002897  000035  var VVREF:=2048;
002898  000036  var VVMAX:=4096;
002899  000037  var OPAMPGAIN:=261;
002900  000038  var INVRHALF:=20833; // 1/R between straps
002901  000039        
002902  000040  var movingState:=0; // used to know whether car is moving or not
002903  000041  var error0:=0; // error0 is when speed is less than 1,
002904  000042  var error1:=0; // error1 for speed>1
002905  000043  var diagnosticError:=0;
002906  000044  var mode, modeChange;
002907  000045  var cellNum:=0;
002908  000046  var cellVolt:=0;
002909  000047  var cellTemp:=0;
002910  000048  var OdometerVal:=0;
002911  000049  var SOC:=0;
002912  000050  var dumSpeed:=0;
002913  000051        
002914  000052  // BMS Menu screen
002915  000053  var PackCurrent:=0;
002916  000054  var coulCountIn:=0; // coulomb counts?
002917  000055  var coulCountBase:=0; // coulomb count base for SOC
002918  000056        
002919  000057  // pack screen
002920  000058  var packNum:=0;
002921  000059  var numOfPacks:=0;
002922  000060  var numOfCells:=0;
002923  000061        
002924  000062  var packCellT[32];
002925  000063  var packCellV[32];
002926  000064        
002927  000065  // driving mode screen
002928  000066  var speed:=0;// from motor controller/simulator?
002929  000067        
002930  000068  // error checking
002931  000069  var upperVolt:=0, lowerVolt:=0;
002932  000070  var upperCurrent:=0;
002933  000071  var upperTemp:=0, lowerTemp:=0;
002934  000072  var voltSafe:=0, tempSafe:=0, curSafe:=0;
002935  000073  var systemVarSafe:=1;
002936  000074  var speedReset:=0;
002937  000075  //CONSTANTS-------------------------------------------------------------
002938  000076  #CONST
002939  000128  #END
002940  000129        
002941  000130  // HELPER FUNCTIONS -------------------------------------------------------
002942  000131        
002943  000132  func decFromChar(var b100, var b10, var b1)
002944  000133      return (b100-48)*100 + (b10-48)*10 + (b1-48);
002945  000134  endfunc
002946  000135        
002947  000136  // write to bms unit through I2C
002948  000137  func BMSWrite(var ad, var com)
002949  000138      I2C_Start();
002950  000139          pause(1);
002951  000140          I2C_Write(ad);
002952  000141          pause(1);
002953  000142          I2C_Write(com);
002954  000143          pause(1);
002955  000144          I2C_Write(0x00);
002956  000145          pause(1);
002957  000146          I2C_Write(0x02);
002958  000147          pause(1);
002959  000148      I2C_Stop();
002960  000149        
002961  000150  endfunc
002962  000151        
002963  000152  func BMSRead8(var ad)
002964  000153      var *bmsdata;
002965  000154        
002966  000155      I2C_Start();
002967  000156          pause(1);
002968  000157          I2C_Write(ad + 0x01);
002969  000158          pause(1);
002970  000159        
002971  000160          bmsdata[0]:=I2C_Read();
002972  000161          I2C_Ack();
002973  000162          pause(1);
002974  000163        
002975  000164          bmsdata[1]:=I2C_Read();
002976  000165          I2C_Ack();
002977  000166          pause(1);
002978  000167        
002979  000168          bmsdata[2]:=I2C_Read();
002980  000169          I2C_Ack();
002981  000170          pause(1);
002982  000171        
002983  000172          bmsdata[3]:=I2C_Read();
002984  000173          I2C_Ack();
002985  000174          pause(1);
002986  000175        
002987  000176          bmsdata[4]:=I2C_Read();
002988  000177          I2C_Ack();
002989  000178          pause(1);
002990  000179        
002991  000180          bmsdata[5]:=I2C_Read();
002992  000181          I2C_Ack();
002993  000182          pause(1);
002994  000183        
002995  000184          bmsdata[6]:=I2C_Read();
002996  000185          I2C_Ack();
002997  000186          pause(1);
002998  000187        
002999  000188          bmsdata[7]:=I2C_Read();
003000  000189          I2C_Nack();
003001  000190      I2C_Stop();
003002  000191        
003003  000192  endfunc
003004  000193        
003005  000194  // for reading 4 bytes from I2C line
003006  000195  func BMSRead4(var ad)
003007  000196      var *bmsdata;
003008  000197        
003009  000198      I2C_Start();
003010  000199          pause(1);
003011  000200          I2C_Write(ad + 0x01);
003012  000201          pause(1);
003013  000202        
003014  000203          bmsdata[0]:=I2C_Read();
003015  000204          I2C_Ack();
003016  000205          pause(1);
003017  000206        
003018  000207          bmsdata[1]:=I2C_Read();
003019  000208          I2C_Ack();
003020  000209          pause(1);
003021  000210        
003022  000211          bmsdata[2]:=I2C_Read();
003023  000212          I2C_Ack();
003024  000213          pause(1);
003025  000214        
003026  000215          bmsdata[3]:=I2C_Read();
003027  000216          I2C_Nack();
003028  000217      I2C_Stop();
003029  000218        
003030  000219      return bmsdata;
003031  000220  endfunc
003032  000221        
003033  000222  // read 2 bytes from bms unit through I2C
003034  000223  func BMSRead2(var ad)
003035  000224      var *bmsdata;
003036  000225        
003037  000226      I2C_Start();
003038  000227          pause(1);
003039  000228          I2C_Write(ad + 0x01);
003040  000229          pause(1);
003041  000230        
003042  000231          bmsdata[0]:=I2C_Read();
003043  000232          I2C_Ack();
003044  000233          pause(1);
003045  000234        
003046  000235          bmsdata[1]:=I2C_Read();
003047  000236          I2C_Nack();
003048  000237      I2C_Stop();
003049  000238        
003050  000239      return bmsdata;
003051  000240        
003052  000241  endfunc
003053  000242        
003054  000243  // convert to valid bms address format
003055  000244  // e.g. getAddress(0,1) is 2nd cell of 1st pack
003056  000245  // used to get address of bms board to communicate via i2c
003057  000246  func getBMSAd(var cell, var pack)
003058  000247      return (pack<<5) || ((cell + 0x01)<<1);
003059  000248  endfunc
003060  000249        
003061  000250  // var 0 to 31 from cellNum and packNum
003062  000251  // needed for updating led values on display
003063  000252  func getCellNum(var cell, var pack)
003064  000253      var ad;
003065  000254      if(pack==1)
003066  000255          ad:= cell + 8;
003067  000256      else if(pack==2)
003068  000257          ad:= cell + 16;
003069  000258      else if(pack==3)
003070  000259          ad:= cell + 24;
003071  000260      else
003072  000261          ad:= cell;
003073  000262      endif
003074  000263        
003075  000264      return ad;
003076  000265  endfunc
003077  000266        
003078  000267  // gets a 16 bit value from high and low byte
003079  000268  func get2Bytes(var high, var low)
003080  000269      var temp;
003081  000270      temp := ByteSwap(high);
003082  000271      return (temp+low);
003083  000272  endfunc
003084  000273        
003085  000274  // returns the max of the cell temperatures
003086  000275  func getMaxTemp()
003087  000276      var max,i,j, cellNum;
003088  000277      max:=0;
003089  000278      for(j:=0;j<numOfPacks;j++)
003090  000279          for(i:=0; i<numOfCells;i++)
003091  000280              cellNum:= getCellNum(i,j);
003092  000281              if (packCellT[cellNum]>max)
003093  000282                  max := packCellT[cellNum];
003094  000283              endif
003095  000284          next
003096  000285      next
003097  000286      return max/10; // adjust for 2 digits (from 3 digits,1 decimal in display)
003098  000287  endfunc
003099  000288        
003100  000289  // print ascii string to file sdata.txt
003101  000290  func println(var str)
003102  000291        
003103  000292      dataHndl:=file_Open(dataFile,'w');
003104  000293      file_Close(dataHndl);
003105  000294        
003106  000295      var i;
003107  000296      if(dataHndl:= file_Open(dataFile,'a'))
003108  000297          for(i:=0;i<str_Length(str);i++)
003109  000298              file_PutC(str[i],dataHndl);
003110  000299          next
003111  000300      endif
003112  000301      file_Close(dataHndl);
003113  000302        
003114  000303        
003115  000304  endfunc
003116  000305        
003117  000306  // converts digital voltage value to analog value equivalent to display
003118  000307  func getAnalogVolt(var d)
003119  000308      return (VVMAX - (VVREF/1024)*d)/10;
003120  000309  endfunc
003121  000310        
003122  000311  // converts digital voltage value to analog value equivalent to display
003123  000312  func getAnalogTemp(var t)
003124  000313      return (VVREF/1024)*t-500;
003125  000314  endfunc
003126  000315        
003127  000316  // converts digital voltage value to analog value equivalent to display
003128  000317  func getAnalogCurrent(var c)
003129  000318      //return ((INVR/(1024))*(VVREF/2000)*c)/(OPAMPGAIN);
003130  000319      return ((INVRHALF/1024)*(VVREF/2000)*c)/(OPAMPGAIN/4);
003131  000320  endfunc
003132  000321        
003133  000322        
003134  000323  // SYSTEM FUNCTIONS ----------------------------------------------------------
003135  000324        
003136  000325  // initialize the screen
003137  000326  func initScreenSetup()
003138  000327        
003139  000328      if (!(disk:=file_Mount()))
003140  000329          while(!(disk :=file_Mount()))
003141  000330              putstr("Drive not mounted...");
003142  000331              pause(200);
003143  000332              gfx_Cls();
003144  000333              pause(200);
003145  000334          wend
003146  000335        
003147  000336          while(!file_Exists("CONFIG.txt"))
003148  000337              putstr("Configuration file not detected...");
003149  000338              pause(200);
003150  000339              gfx_Cls();
003151  000340              pause(200);
003152  000341          wend
003153  000342        
003154  000343          putstr("Drive mount successful. Please wait...");
003155  000344          pause(2000);
003156  000345      endif
003157  000346        
003158  000347      gfx_TransparentColour(0x0020);
003159  000348      gfx_Transparency(ON);
003160  000349        
003161  000350  //  hFontn := file_LoadImageControl("MAINSC~1.dan", "MAINSC~1.gcn", 1); // Open handle to access uSD fonts, uncomment if required and change n to font number dropping a and c if > 9
003162  000351  //  hstrings := file_Open("MAINSC~1.txf", 'r') ; // Open handle to access uSD strings, uncomment if required
003163  000352      hndl := file_LoadImageControl("SE7M51~5.dat", "SE7M51~5.gci", 1);
003164  000353        
003165  000354      gfx_Set(SCREEN_MODE,LANDSCAPE);
003166  000355        
003167  000356      touch_Set(TOUCH_ENABLE);
003168  000357        
003169  000358  endfunc
003170  000359        
003171  000360  // function to check system paramters for errors
003172  000361  func errorCheck()
003173  000362        
003174  000363      error0:=0;
003175  000364      error1:=0;
003176  000365        
003177  000366      if(mode!=ERROR)
003178  000367          pin_HI(SAFETYLOOPCTRL);
003179  000368      endif
003180  000369        
003181  000370      SafetyLoopState := pin_Read(SAFETYLOOPIN);
003182  000371      subSystemBool:= BMSConnection && MotorContConnection;
003183  000372        
003184  000373      // UPDATE SYSTEM STATE VARIABLES
003185  000374      var i, j, cellNum;
003186  000375        
003187  000376      if(BMSConnection)
003188  000377          // PACK1 VOLTS CHECK -------------------------------------------------
003189  000378          for(j:=0;j<numOfPacks;j++)
003190  000379              for(i:=0;i<numOfCells;i++)
003191  000380                  cellNum:=getCellNum(i,j);
003192  000381                  if( packCellV[cellNum] >= lowerVolt && packCellV[cellNum]<=upperVolt)
003193  000382                      voltSafe:=1;
003194  000383                  else
003195  000384                      voltSafe:=0;
003196  000385                  endif
003197  000386              next
003198  000387          next
003199  000388        
003200  000389          // TEMP CHECK -------------------------------------------------------
003201  000390          if( getMaxTemp() >= lowerTemp && getMaxTemp() <= upperTemp)
003202  000391              tempSafe:=1;
003203  000392          else
003204  000393              tempSafe:=0;
003205  000394          endif
003206  000395        
003207  000396          // CURRENT CHECK ---------------------------------------------------
003208  000397          if( PackCurrent <= upperCurrent)
003209  000398              curSafe:=1;
003210  000399          else
003211  000400              curSafe:=0;
003212  000401          endif
003213  000402        
003214  000403          systemVarSafe:= tempSafe && curSafe &&  voltSafe;
003215  000404      endif // end if bmsconnection
003216  000405        
003217  000406      // SUBSYSTEM/VARIABLE CHECK -----------------------------------------------------
003218  000407        
003219  000408      // check speed to know if driving or not
003220  000409      if(speed > 5)
003221  000410          movingState:=1;
003222  000411      else
003223  000412          movingState:=0;
003224  000413      endif
003225  000414        
003226  000415      if(subSystemBool && systemVarSafe && SafetyLoopState)
003227  000416          ReadyToDrive:=1;
003228  000417      else
003229  000418          ReadyToDrive:=0;
003230  000419      endif
003231  000420        
003232  000421        
003233  000422      // go to error screen upon exceeding cell data bounds
003234  000423      // or if bms is disconnected
003235  000424        
003236  000425      if(!systemVarSafe && !LC_ON)
003237  000426          error0:=1;
003238  000427      else
003239  000428          error0:=0;
003240  000429      endif
003241  000430        
003242  000431      // check overall system variables and safety
003243  000432      if(LC_ON)
003244  000433          if(!subSystemBool || !systemVarSafe || !SafetyLoopState)
003245  000434              error1:=1;
003246  000435          else
003247  000436              error1:=0;
003248  000437          endif
003249  000438      endif
003250  000439        
003251  000447  */
003252  000448  //    if(LC_ON && !BMSConnection)
003253  000449  //        error1:=1;
003254  000450  //    else
003255  000451  //        error1:=0;
003256  000452  //    endif
003257  000453        
003258  000454  endfunc
003259  000455        
003260  000456  // Handles touch: buttons etc.
003261  000457  func processTouch()
003262  000458      if(touch_Get(TOUCH_STATUS) == TOUCH_PRESSED)
003263  000459        
003264  000460          // IN DIAGNOSTIC MODE------------------------------------------
003265  000461          // team info button
003266  000462          if(mode == DIAGNOSTIC && img_Touched(hndl,iTeamInfoButton)==iTeamInfoButton)
003267  000463              mode:= TEAMINFO;
003268  000464              modeChange:=1;
003269  000465        
003270  000466          // touch bms menu
003271  000467          else if(mode== DIAGNOSTIC && img_Touched(hndl,iBMSMenuButton1)==iBMSMenuButton1)
003272  000468              if(BMSConnection)
003273  000469                  mode := BMSMENU;
003274  000470                  modeChange := 1;
003275  000471              endif
003276  000472        
003277  000473        
003278  000474          // ready to drive button
003279  000475          else if(mode==DIAGNOSTIC && img_Touched(hndl,iReadyToDrive)==iReadyToDrive)
003280  000476              // hold for 5 seconds
003281  000477              var driveHold:=0;
003282  000478        
003283  000479              if(ReadyToDrive)
003284  000480                  mode := DRIVING;
003285  000481                  modeChange := 1;
003286  000482                  pin_LO(LCIR); // turn on IR
003287  000483                  LC_ON:=1;
003288  000484              endif
003289  000485        
003290  000486          // motor controller button
003291  000487          else if(mode==DIAGNOSTIC && img_Touched(hndl, iMCButton)==iMCButton)
003292  000488              mode:= MOTORCONT;
003293  000489              modeChange := 1;
003294  000490        
003295  000491          // IN BMS MENU----------------------------------------------
003296  000492        
003297  000493          // main menu button
003298  000494          else if(mode==BMSMENU && !LC_ON && img_Touched(hndl, iBMSBackToMain)==iBMSBackToMain)
003299  000495              mode:= DIAGNOSTIC;
003300  000496              modeChange:=1;
003301  000497        
003302  000498          // back to drive menu button while driving
003303  000499          else if(mode==BMSMENU && LC_ON && img_Touched(hndl, iBMSToDriveMenu)==iBMSToDriveMenu)
003304  000500              mode:= DRIVING;
003305  000501              modeChange:=1;
003306  000502        
003307  000503          // pack1 button
003308  000504          else if(mode==BMSMENU && img_Touched(hndl, iPack1Button)==iPack1Button)
003309  000505              mode:= BMSPACK1;
003310  000506              modeChange:=1;
003311  000507        
003312  000508          // repeat for other packs. refer to touchscreen help - button coordinates.xlsx
003313  000509        
003314  000510          // PACK1 DATA SCREEN --------------------------------------------
003315  000511        
003316  000512          // main menu button
003317  000513          else if(mode == BMSPACK1 && !LC_ON && img_Touched(hndl, iPack1BackToMain)==iPack1BackToMain)
003318  000514              mode:= DIAGNOSTIC;
003319  000515              modeChange:=1;
003320  000516        
003321  000517           // drive screen button
003322  000518          else if(mode == BMSPACK1 && LC_ON && img_Touched(hndl, iPackToDriveMenu)==iPackToDriveMenu)
003323  000519              mode:= DRIVING;
003324  000520              modeChange:=1;
003325  000521        
003326  000522          // bms menu button
003327  000523          else if(mode == BMSPACK1 && img_Touched(hndl, iPack1BMSMenu)==iPack1BMSMenu)
003328  000524              mode:=BMSMENU;
003329  000525              modeChange:=1;
003330  000526        
003331  000527          // IN DRIVING MODE--------------------------------------------------
003332  000528        
003333  000529          // Turn off button
003334  000530          else if(mode==DRIVING && img_Touched(hndl, iTurnOffDrive)==iTurnOffDrive)
003335  000531              // touch for 5 seconds, edit for moving/not moving
003336  000532              if(!movingState)
003337  000533                  mode := DIAGNOSTIC;
003338  000534                  modeChange := 1;
003339  000535                  pin_HI(LCIR);
003340  000536                  LC_ON:=0;
003341  000537                  // TURN OFF LC IR
003342  000538              endif
003343  000539        
003344  000540          // BMS MENU button for Driving Mode
003345  000541          else if(mode==DRIVING && img_Touched(hndl, iDriveBMSMenu)==iDriveBMSMenu)
003346  000542              mode:=BMSMENU;
003347  000543              modeChange:=1;
003348  000544        
003349  000545          // reset trip
003350  000546          else if(mode==DRIVING && img_Touched(hndl, iResetTrip)==iResetTrip)
003351  000547              OdometerVal:=0;
003352  000548              dumSpeed:=0;
003353  000549        
003354  000550          // IN MOTOR CONTROL SCREEN ---------------------------------------------
003355  000551          else if(mode== MOTORCONT && img_Touched(hndl, iMCMainMenuButton)==iMCMainMenuButton)
003356  000552              mode:=DIAGNOSTIC;
003357  000553              modeChange:=1;
003358  000554        
003359  000555          // in TEAM INFO page, to get back to main menu --------------------------------
003360  000556          else if(mode==TEAMINFO)
003361  000557              mode:=DIAGNOSTIC;
003362  000558              modeChange:=1;
003363  000559        
003364  000560          // ERROR SCREEN -------------------------------------------------------------
003365  000561          else if(mode==ERROR && img_Touched(hndl, iErrorBackToMain)==iErrorBackToMain)
003366  000562              mode:=DIAGNOSTIC;
003367  000563              modeChange:=1;
003368  000564          endif
003369  000565        
003370  000566      endif
003371  000567  endfunc
003372  000568        
003373  000569  // handles serial commands from Arduino and store system values
003374  000570  func serialCommands()
003375  000605      */
003376  000606        
003377  000607  endfunc
003378  000608        
003379  000609  // changes screen according to mode
003380  000610  func changeDisplayMode()
003381  000611      if(modeChange == 1)
003382  000612              gfx_Cls();
003383  000613              // changes screen to appropriate mode
003384  000614              if(mode == DRIVING)
003385  000615                  driveModeInit();
003386  000616              else if(mode == BMSMENU)
003387  000617                  BMSMenuInit();
003388  000618               else if(mode == BMSPACK1)
003389  000619                  BMSPack1Init();
003390  000620              else if(mode == DIAGNOSTIC)
003391  000621                  diagnosticModeInit();
003392  000622              else if(mode == MOTORCONT)
003393  000623                  motorControlInit();
003394  000624              else if(mode==TEAMINFO)
003395  000625                  teamInfoPage();
003396  000626              else if(mode==ERROR)
003397  000627                  errorScreenInit();
003398  000628              // else if other modes etc
003399  000629        
003400  000630              endif
003401  000631              modeChange := 0;
003402  000632          endif
003403  000633  endfunc
003404  000634        
003405  000635  // updates the variables/digits/buttons on the display according to mode/state
003406  000636  func updateDisplay()
003407  000637        
003408  000638      if(mode!=ERROR)
003409  000639          if(error0)
003410  000640              mode:=ERROR;
003411  000641              modeChange:=1;
003412  000642              pin_LO(SAFETYLOOPCTRL); // shut off safetyLoop
003413  000643              return;
003414  000644          else if(error1)
003415  000645              mode:=ERROR;
003416  000646              modeChange:=1;
003417  000647              pin_HI(LCIR); // first shut off Load Controller IR's
003418  000648              LC_ON:=0;
003419  000649              pause(1000); // wait at least 1 second
003420  000650              pin_LO(SAFETYLOOPCTRL); // then open Safety Loop
003421  000651              return;
003422  000652          endif
003423  000653      endif
003424  000654        
003425  000655      // DIAGNOSTIC MODE ----------------------------------------------------
003426  000656      if(mode == DIAGNOSTIC)
003427  000657        
003428  000658          //monitor status of the safety
003429  000659          if(SafetyLoopState)
003430  000660              // SLOpen 1.0 generated 3/14/2013 3:02:57 PM
003431  000661              gfx_CircleFilled(66, 202, 6, LIME) ;
003432  000662          else
003433  000663              // SLOpen 1.0 generated 3/11/2013 8:38:37 PM
003434  000664              gfx_CircleFilled(66, 202, 6, RED) ;
003435  000665          endif
003436  000666        
003437  000667          // check bms connection
003438  000668          if(BMSConnection)
003439  000669              // BMSMenuButton1 1.0 generated 3/8/2013 2:14:58 AM
003440  000670              img_SetWord(hndl, iBMSMenuButton1, IMAGE_FLAGS, (img_GetWord(hndl, iBMSMenuButton1, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003441  000671              img_SetWord(hndl, iBMSMenuButton1, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003442  000672              img_Show(hndl,iBMSMenuButton1) ;
003443  000673              // BMSLED 1.0 generated 3/14/2013 3:03:22 PM
003444  000674              gfx_CircleFilled(66, 222, 6, LIME) ;
003445  000675          else
003446  000676              // BMSMenuDisconnect 1.0 generated 3/21/2013 3:46:37 PM
003447  000677              img_SetWord(hndl, iBMSMenuDisconnect, IMAGE_FLAGS, (img_GetWord(hndl, iBMSMenuDisconnect, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003448  000678              img_SetWord(hndl, iBMSMenuDisconnect, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003449  000679              img_Show(hndl,iBMSMenuDisconnect) ;
003450  000680              gfx_CircleFilled(66, 222, 6, RED) ;
003451  000681          endif
003452  000682        
003453  000683          // check if safe to drive
003454  000684          if(ReadyToDrive)
003455  000685              // ReadyToDrive 1.0 generated 3/8/2013 2:14:58 AM
003456  000686              img_SetWord(hndl, iReadyToDrive, IMAGE_FLAGS, (img_GetWord(hndl, iReadyToDrive, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003457  000687              img_SetWord(hndl, iReadyToDrive, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003458  000688              img_Lighten(hndl, iReadyToDrive);
003459  000689              img_Show(hndl,iReadyToDrive) ;
003460  000690        
003461  000691          else
003462  000692              // Winbutton2 1.0 generated 3/11/2013 7:15:52 PM
003463  000693              img_SetWord(hndl, iCantDrive, IMAGE_FLAGS, (img_GetWord(hndl, iCantDrive, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003464  000694              img_SetWord(hndl, iCantDrive, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003465  000695              img_Show(hndl,iCantDrive) ;
003466  000696              // diagnosticWarningText 1.0 generated 3/11/2013 7:20:16 PM
003467  000697        
003468  000698          endif
003469  000699        
003470  000700          // check status of motor controller
003471  000701          if(MotorContConnection)
003472  000702              // MCButton 1.0 generated 3/11/2013 7:23:43 PM
003473  000703              img_SetWord(hndl, iMCButton, IMAGE_FLAGS, (img_GetWord(hndl, iMCButton, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003474  000704              img_SetWord(hndl, iMCButton, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003475  000705              img_Show(hndl,iMCButton) ;
003476  000706              // MOTORLED 1.0 generated 3/14/2013 3:03:48 PM
003477  000707              gfx_CircleFilled(66, 242, 6, LIME) ;
003478  000708          else
003479  000709              // MotorContDisc 1.0 generated 3/11/2013 7:25:31 PM
003480  000710              img_SetWord(hndl, iMotorContDisconnect, IMAGE_FLAGS, (img_GetWord(hndl, iMotorContDisconnect, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003481  000711              img_SetWord(hndl, iMotorContDisconnect, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003482  000712              img_Show(hndl,iMotorContDisconnect) ;
003483  000713              gfx_CircleFilled(66, 242, 6, RED) ;
003484  000714          endif
003485  000715        
003486  000716      // DRIVING MODE -------------------------------------------------------------
003487  000717      else if(mode == DRIVING)
003488  000718          if(!movingState)
003489  000719              // TurnOffDrive 1.0 generated 3/11/2013 1:12:38 PM
003490  000720              img_SetWord(hndl, iTurnOffDrive, IMAGE_FLAGS, (img_GetWord(hndl, iTurnOffDrive, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003491  000721              img_SetWord(hndl, iTurnOffDrive, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003492  000722              img_Show(hndl,iTurnOffDrive) ;
003493  000723              img_Disable(hndl, iCantTurnOffLabel);
003494  000724              img_Show(hndl,iCantTurnOffLabel) ;
003495  000725          else
003496  000726              // BLOCK THE TURN OFF BUTTON
003497  000727              // CantTurnOff 1.0 generated 3/11/2013 10:21:40 PM
003498  000728              img_SetWord(hndl, iCantTurnOff, IMAGE_FLAGS, (img_GetWord(hndl, iCantTurnOff, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003499  000729              img_SetWord( hndl, iCantTurnOff, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003500  000730              img_Show(hndl,iCantTurnOff) ;
003501  000731              img_Enable(hndl, iCantTurnOffLabel);
003502  000732              img_Show(hndl,iCantTurnOffLabel);
003503  000733          endif
003504  000734        
003505  000735          // SpeedValue 1.0 generated 3/11/2013 9:57:04 PM
003506  000736          ledDigitsDisplay(speed, iSpeedValue+1, 136, 3, 2, 59, 0) ;
003507  000737        
003508  000738          // BatLevelLED 1.0 generated 4/26/2013 3:22:37 PM
003509  000739          ledDigitsDisplay(SOC, iBatLevelLED+1, 100, 3, 1, 35, 0) ;
003510  000740        
003511  000741          // PackCurrentLED 1.0 generated 4/26/2013 3:23:06 PM
003512  000742          ledDigitsDisplay(PackCurrent, iPackCurrentLED+1, 256, 3, 1, 35, 0) ;
003513  000743        
003514  000744          // OdometerVal 1.0 generated 3/11/2013 9:57:05 PM
003515  000745          ledDigitsDisplay(OdometerVal, iOdometerVal+1, 96, 3, 2, 30, 0) ;
003516  000746        
003517  000747          //img_SetWord(hndl, iTemperature, IMAGE_INDEX, 30) ; // where frame is 0 to 130 (for a displayed -1 to -1)
003518  000748          // Temperature 1.0 generated 5/5/2013 1:41:54 PM
003519  000749          img_SetWord(hndl, iTemperature, IMAGE_INDEX, getMaxTemp()) ; // where frame is 0 to 130 (for a displayed -1 to -1)
003520  000750          img_Show(hndl,iTemperature) ;
003521  000751        
003522  000752      // BMS MENU -------------------------------------------------------------------
003523  000753      else if(mode == BMSMENU)
003524  000754        
003525  000755          // while just viewing status of cells, if anything is disconnected
003526  000756          if((!LC_ON && !BMSConnection))//|| !SafetyLoopState)
003527  000757              mode:=DIAGNOSTIC;
003528  000758              modeChange:=1;
003529  000759              return;
003530  000760          endif
003531  000761        
003532  000762              // PackCurrent 1.0 generated 3/8/2013 2:13:21 AM
003533  000763              ledDigitsDisplay(PackCurrent, iPackCurrent+1, 136, 3, 1, 23, 0) ;
003534  000764              // BMSMenuSOC 1.0 generated 3/8/2013 2:13:21 AM
003535  000765              ledDigitsDisplay(SOC, iBMSMenuSOC+1, 352, 3, 1, 23, 0) ;
003536  000766        
003537  000767          if(LC_ON)
003538  000768              // BMSToDriveMenu 1.0 generated 4/23/2013 10:14:49 PM
003539  000769              img_SetWord(hndl, iBMSToDriveMenu, IMAGE_FLAGS, (img_GetWord(hndl, iBMSToDriveMenu, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003540  000770              img_SetWord(hndl, iBMSToDriveMenu, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003541  000771              img_Show(hndl,iBMSToDriveMenu) ;
003542  000772          else
003543  000773              // BMSBackToMain 1.0 generated 3/8/2013 2:13:21 AM
003544  000774              img_SetWord(hndl, iBMSBackToMain, IMAGE_FLAGS, (img_GetWord(hndl, iBMSBackToMain, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003545  000775              img_SetWord(hndl, iBMSBackToMain, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003546  000776              img_Show(hndl,iBMSBackToMain) ;
003547  000777          endif
003548  000778        
003549  000779          if(numOfPacks>=2)
003550  000780              // Pack2Button 1.0 generated 3/8/2013 2:13:21 AM
003551  000781              img_SetWord(hndl, iPack2Button, IMAGE_FLAGS, (img_GetWord(hndl, iPack2Button, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003552  000782              img_SetWord(hndl, iPack2Button, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003553  000783              img_Show(hndl,iPack2Button) ;
003554  000784          else
003555  000785              // NoPack2B 1.0 generated 5/5/2013 11:24:52 AM
003556  000786              img_SetWord(hndl, iNoPack2B, IMAGE_FLAGS, (img_GetWord(hndl, iNoPack2B, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003557  000787              img_SetWord(hndl, iNoPack2B, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003558  000788              img_Show(hndl,iNoPack2B) ;
003559  000789          endif
003560  000790        
003561  000791          if(numOfPacks>=3)
003562  000792              // Pack3Button 1.0 generated 3/8/2013 2:13:21 AM
003563  000793              img_SetWord(hndl, iPack3Button, IMAGE_FLAGS, (img_GetWord(hndl, iPack3Button, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003564  000794              img_SetWord(hndl, iPack3Button, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003565  000795              img_Show(hndl,iPack3Button) ;
003566  000796          else
003567  000797              // NoPack3B 1.0 generated 5/5/2013 11:25:34 AM
003568  000798              img_SetWord(hndl, iNoPack3B, IMAGE_FLAGS, (img_GetWord(hndl, iNoPack3B, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003569  000799              img_SetWord(hndl, iNoPack3B, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003570  000800              img_Show(hndl,iNoPack3B) ;
003571  000801          endif
003572  000802        
003573  000803          if(numOfPacks==4)
003574  000804              // Pack4Button 1.0 generated 3/8/2013 2:13:21 AM
003575  000805              img_SetWord(hndl, iPack4Button, IMAGE_FLAGS, (img_GetWord(hndl, iPack4Button, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003576  000806              img_SetWord(hndl, iPack4Button, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003577  000807              img_Show(hndl,iPack4Button) ;
003578  000808          else
003579  000809              // NoPack4B 1.0 generated 5/5/2013 11:25:50 AM
003580  000810              img_SetWord(hndl, iNoPack4B, IMAGE_FLAGS, (img_GetWord(hndl, iNoPack4B, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003581  000811              img_SetWord(hndl, iNoPack4B, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003582  000812              img_Show(hndl,iNoPack4B) ;
003583  000813          endif
003584  000814        
003585  000815      // PACK 1 SCREEN -------------------------------------------------------------
003586  000816      else if(mode==BMSPACK1)
003587  000817        
003588  000818          // while just viewing status of cells, if anything is disconnected
003589  000819          if((!LC_ON && !BMSConnection)) // || !SafetyLoopState)
003590  000820              mode:=DIAGNOSTIC;
003591  000821              modeChange:=1;
003592  000822              return;
003593  000823          endif
003594  000824        
003595  000825          if(LC_ON)
003596  000826              // PackToDriveMenu 1.0 generated 4/23/2013 10:23:13 PM
003597  000827              img_SetWord(hndl, iPackToDriveMenu, IMAGE_FLAGS, (img_GetWord(hndl, iPackToDriveMenu, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003598  000828              img_SetWord(hndl, iPackToDriveMenu, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003599  000829              img_Show(hndl,iPackToDriveMenu) ;
003600  000830          else
003601  000831               // Pack1BackToMain 1.0 generated 3/11/2013 3:37:29 PM
003602  000832              img_SetWord(hndl, iPack1BackToMain, IMAGE_FLAGS, (img_GetWord(hndl, iPack1BackToMain, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003603  000833              img_SetWord(hndl, iPack1BackToMain, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
003604  000834              img_Show(hndl,iPack1BackToMain) ;
003605  000835          endif
003606  000836        
003607  000837          // Pack1Current 1.0 generated 3/11/2013 3:37:29 PM
003608  000838          ledDigitsDisplay(PackCurrent, iPack1Current+1, 396, 3, 1, 21, 0) ;
003609  000839          // Pack1SOC 1.0 generated 3/11/2013 3:37:29 PM
003610  000840          ledDigitsDisplay(SOC, iPack1SOC+1, 396, 3, 1, 21, 0) ;
003611  000841        
003612  000842          if(numOfCells >= 1)
003613  000843              // clabel1 1.0 generated 3/11/2013 3:37:29 PM
003614  000844              img_Show(hndl,iclabel1) ;
003615  000845              // Pack1Cell1V 1.0 generated 3/8/2013 12:22:29 AM
003616  000846              ledDigitsDisplay(packCellV[0], iPack1Cell1V+1, 76, 3, 3, 20, 0) ;
003617  000847              // Pack1Cell1Temp 1.0 generated 3/8/2013 12:22:29 AM
003618  000848              ledDigitsDisplay(packCellT[0], iPack1Cell1Temp+1, 76, 3, 2, 20, 0) ;
003619  000849          endif
003620  000850        
003621  000851          if(numOfCells >= 2)
003622  000852              // clabel2 1.0 generated 3/11/2013 3:37:29 PM
003623  000853              img_Show(hndl,iclabel2) ;
003624  000854              // Pack1Cell2V 1.0 generated 3/8/2013 12:22:29 AM
003625  000855              ledDigitsDisplay(packCellV[1], iPack1Cell2V+1, 152, 3, 3, 20, 0) ;
003626  000856              // Pack1Cell2Temp 1.0 generated 3/8/2013 12:22:29 AM
003627  000857              ledDigitsDisplay(packCellT[1], iPack1Cell2Temp+1, 152, 3, 2, 20, 0) ;
003628  000858          endif
003629  000859        
003630  000860          if(numOfCells >= 3)
003631  000861              // clabel3 1.0 generated 3/11/2013 3:37:29 PM
003632  000862              img_Show(hndl,iclabel3) ;
003633  000863              // Pack1Cell3V 1.0 generated 3/8/2013 12:22:29 AM
003634  000864              ledDigitsDisplay(packCellV[2], iPack1Cell3V+1, 228, 3, 3, 20, 0) ;
003635  000865              // Pack1Cell3Temp 1.0 generated 3/8/2013 12:22:29 AM
003636  000866              ledDigitsDisplay(packCellT[2], iPack1Cell3Temp+1, 228, 3, 2, 20, 0) ;
003637  000867          endif
003638  000868        
003639  000869          if(numOfCells >= 4)
003640  000870              // clabel4 1.0 generated 3/11/2013 3:37:29 PM
003641  000871              img_Show(hndl,iclabel4) ;
003642  000872              // Pack1Cell4V 1.0 generated 3/8/2013 12:22:29 AM
003643  000873              ledDigitsDisplay(packCellV[3], iPack1Cell4V+1, 304, 3, 3, 20, 0) ;
003644  000874              // Pack1Cell4Temp 1.0 generated 3/8/2013 12:22:29 AM
003645  000875              ledDigitsDisplay(packCellT[3], iPack1Cell4Temp+1, 304, 3, 2, 20, 0) ;
003646  000876          endif
003647  000877        
003648  000878          if(numOfCells >= 5)
003649  000879              // voltlabel2 1.0 generated 3/11/2013 3:37:29 PM
003650  000880              img_Show(hndl,ivoltlabel2) ;
003651  000881              // templabel2 1.0 generated 3/11/2013 3:37:29 PM
003652  000882              img_Show(hndl,itemplabel2) ;
003653  000883        
003654  000884              // cellLabel5 1.0 generated 3/11/2013 3:37:29 PM
003655  000885              img_Show(hndl,icellLabel5) ;
003656  000886              // Pack1Cell5Temp 1.0 generated 3/8/2013 12:22:29 AM
003657  000887              ledDigitsDisplay(packCellV[4], iPack1Cell5V+1, 76, 3, 2, 20, 0) ;
003658  000888              // Pack1Cell5V 1.0 generated 3/8/2013 12:22:29 AM
003659  000889              ledDigitsDisplay(packCellT[4], iPack1Cell5Temp+1, 76, 3, 3, 20, 0) ;
003660  000890          endif
003661  000891        
003662  000892          if(numOfCells >= 6)
003663  000893              // cellLabel6 1.0 generated 3/11/2013 3:37:29 PM
003664  000894              img_Show(hndl,icellLabel6) ;
003665  000895              // Pack1Cell6Temp 1.0 generated 3/8/2013 12:22:29 AM
003666  000896              ledDigitsDisplay(packCellV[5], iPack1Cell6V+1, 152, 3, 2, 20, 0) ;
003667  000897              // Pack1Cell6V 1.0 generated 3/8/2013 12:22:29 AM
003668  000898              ledDigitsDisplay(packCellT[5], iPack1Cell6Temp+1, 152, 3, 3, 20, 0) ;
003669  000899          endif
003670  000900        
003671  000901          if(numOfCells >= 7)
003672  000902              // cellLabel7 1.0 generated 3/11/2013 3:37:29 PM
003673  000903              img_Show(hndl,icellLabel7);
003674  000904              // Pack1Cell7Temp 1.0 generated 3/8/2013 12:22:29 AM
003675  000905              ledDigitsDisplay(packCellV[6], iPack1Cell7V+1, 228, 3, 2, 20, 0) ;
003676  000906              // Pack1Cell7V 1.0 generated 3/8/2013 12:22:29 AM
003677  000907              ledDigitsDisplay(packCellT[6], iPack1Cell7Temp+1, 228, 3, 3, 20, 0) ;
003678  000908          endif
003679  000909        
003680  000910          if(numOfCells >= 8)
003681  000911              // Pack1Cell8V 1.0 generated 3/8/2013 12:22:29 AM
003682  000912              ledDigitsDisplay(packCellV[7], iPack1Cell8V+1, 304, 3, 3, 20, 0) ;
003683  000913              // Pack1Cell8Temp 1.0 generated 3/8/2013 12:22:29 AM
003684  000914              ledDigitsDisplay(packCellT[7], iPack1Cell8Temp+1, 304, 3, 2, 20, 0) ;
003685  000915              // cellLabel8 1.0 generated 3/11/2013 3:37:29 PM
003686  000916              img_Show(hndl,icellLabel8) ;
003687  000917          endif
003688  000918        
003689  000919      // REPEAT FOR 3 MORE PACKS
003690  001211      */
003691  001212      // end of pack 4
003692  001213        
003693  001214      else if(mode==ERROR)
003694  001215        
003695  001216          pin_LO(SAFETYLOOPCTRL);
003696  001217        
003697  001218          // to allow user to go back to diagnostic mode once bms is disconnected
003698  001219          if(!BMSConnection)
003699  001220              systemVarSafe:=1; // cheat
003700  001221          endif
003701  001222        
003702  001223          if(SafetyLoopState)
003703  001224              // safetyLED 1.0 generated 4/24/2013 1:42:56 AM
003704  001225              gfx_CircleFilled(86, 130, 6, LIME) ;
003705  001226          else
003706  001227              // safetyLED 1.0 generated 4/24/2013 1:42:56 AM
003707  001228              gfx_CircleFilled(86, 130, 6, RED) ;
003708  001229          endif
003709  001230        
003710  001231          if(BMSConnection)
003711  001232              // bmsLED 1.0 generated 4/24/2013 1:44:51 AM
003712  001233              gfx_CircleFilled(86, 154, 6, LIME) ;
003713  001234          else
003714  001235              // bmsLED 1.0 generated 4/24/2013 1:44:51 AM
003715  001236              gfx_CircleFilled(86, 154, 6, RED) ;
003716  001237          endif
003717  001238        
003718  001239          if(MotorContConnection)
003719  001240              // motorLED 1.0 generated 4/24/2013 1:45:19 AM
003720  001241              gfx_CircleFilled(86, 178, 6, LIME) ;
003721  001242          else
003722  001243              // motorLED 1.0 generated 4/24/2013 1:45:19 AM
003723  001244              gfx_CircleFilled(86, 178, 6, RED) ;
003724  001245          endif
003725  001246        
003726  001247          if(voltSafe)
003727  001248              // voltLED 1.0 generated 4/24/2013 1:45:40 AM
003728  001249              gfx_CircleFilled(238, 130, 6, LIME) ;
003729  001250          else
003730  001251              // voltLED 1.0 generated 4/24/2013 1:45:40 AM
003731  001252              gfx_CircleFilled(238, 130, 6, RED) ;
003732  001253          endif
003733  001254        
003734  001255          if(tempSafe)
003735  001256              // tempLED 1.0 generated 4/24/2013 1:46:07 AM
003736  001257              gfx_CircleFilled(238, 154, 6, LIME) ;
003737  001258          else
003738  001259              // tempLED 1.0 generated 4/24/2013 1:46:07 AM
003739  001260              gfx_CircleFilled(238, 154, 6, RED) ;
003740  001261          endif
003741  001262        
003742  001263          if(curSafe)
003743  001264              // curLED 1.0 generated 4/24/2013 1:46:28 AM
003744  001265              gfx_CircleFilled(238, 178, 6, LIME) ;
003745  001266          else
003746  001267              // curLED 1.0 generated 4/24/2013 1:46:28 AM
003747  001268              gfx_CircleFilled(238, 178, 6, RED) ;
003748  001269          endif
003749  001270        
003750  001271              // error mode, show error screen without slow down label
003751  001272          if(!movingState)
003752  001273              img_Disable(hndl, iSlowDown);
003753  001274              img_Show(hndl,iSlowDown);
003754  001275          else
003755  001276              img_Enable(hndl, iSlowDown);
003756  001277              img_Show(hndl,iSlowDown);
003757  001278          endif
003758  001279        
003759  001280      endif // end elses
003760  001281        
003761  001282        
003762  001283        
003763  001284  endfunc
003764  001285        
003765  001286  // check subsystem connections
003766  001287  func checkConnections()
003767  001288      // BMSConnection:= pin_Read(1);
003768  001289      SafetyLoopState := pin_Read(SAFETYLOOPIN);
003769  001290        
003770  001291      // check for subsystem error
003771  001292      subSystemBool := BMSConnection==1 && MotorContConnection==1;
003772  001293        
003773  001294      // check if safe to start driving from DIAGNOSTIC Mode
003774  001295      if(subSystemBool)
003775  001296          ReadyToDrive:=1;
003776  001297      else
003777  001298          ReadyToDrive:=0;
003778  001299      endif
003779  001300        
003780  001301  endfunc
003781  001302        
003782  001303  // configure system parameters using configuration file on sd card
003783  001304  func systemConfig()
003784  001305      configHndl:= file_Open(configFile,'r');
003785  001306      var packstring[120];
003786  001307      file_GetS(packstring,120,configHndl);
003787  001308      //var i;
003788  001309        
003789  001310      numOfPacks:=packstring[6]-48;
003790  001311      numOfCells:=packstring[13]-48;
003791  001312        
003792  001313      lowerVolt:= decFromChar(packstring[20],packstring[21],packstring[22]);
003793  001314      upperVolt:= decFromChar(packstring[29],packstring[30],packstring[31]);
003794  001315        
003795  001316      lowerTemp:= decFromChar(packstring[38],packstring[39],packstring[40]);
003796  001317      upperTemp:= decFromChar(packstring[47],packstring[48],packstring[49]);
003797  001318        
003798  001319      upperCurrent:= decFromChar(packstring[56],packstring[57],packstring[58]);
003799  001320        
003800  001321  endfunc
003801  001322        
003802  001323        
003803  001324  // updates speed on dispay
003804  001325  func checkSpeed()
003805  001326        
003806  001327      if(pin_Read(SPEEDPOT))
003807  001328          speed:=0;
003808  001329          movingState:=0;
003809  001330      else
003810  001331          speed:=600;
003811  001332          movingState:=1;
003812  001333          dumSpeed+=1; // dummy speed variable
003813  001334      endif
003814  001335        
003815  001336      OdometerVal:= dumSpeed/30; // dumb method to increase trip
003816  001337  endfunc
003817  001338        
003818  001339        
003819  001340  // print cell data to sd card in data filefunc logData()
003820  001341  func logData()
003821  001342      var *string;
003822  001343        
003823  001344        
003824  001345        
003825  001346        
003826  001347        
003827  001348  endfunc
003828  001349        
003829  001350  // check connection and get cell data from the BMS
003830  001351  // update all the cell data value variables
003831  001352  func getBMSData()
003832  001353        
003833  001354      var i,j, ad, adp;
003834  001355      var *bmsdata;
003835  001356        
003836  001357      // avoid spurious address reset
003837  001358     // BMSWrite(0x00,0x01);
003838  001359        
003839  001360      // CHECK CONNECTION ----------------------------------------------
003840  001361      var bmsCx:=0;
003841  001362      for(j:=0;j<numOfPacks;j++)
003842  001363          for (i:=0;i<numOfCells;i++)
003843  001364              ad:=getBMSAd(i,j);
003844  001365              BMSWrite(ad, GETADDRESS);
003845  001366              BMSWrite(ad, GETADDRESS);
003846  001367              BMSWrite(ad, GETADDRESS);
003847  001368              bmsdata:=BMSRead2(ad);
003848  001369              if(get2Bytes(bmsdata[0],bmsdata[1]) == ad)
003849  001370                  bmsCx++;
003850  001371              endif
003851  001372              pause(1);
003852  001373          next
003853  001374      next
003854  001375        
003855  001376      if(bmsCx == numOfCells*numOfPacks)
003856  001377          BMSConnection:=1;
003857  001378      else
003858  001379          BMSConnection:=0;
003859  001380      endif
003860  001381        
003861  001382      // READ DATA --------------------------------------------------------
003862  001383        
003863  001384      var meanValC, meanValV, meanValT, analogT, analogV, analogCur;
003864  001385      if(BMSConnection)
003865  001386          // read current measurement from the first cell
003866  001387          BMSWrite(0x02, GETPACKCUR);
003867  001388          bmsdata:=BMSRead2(0x02);
003868  001389          analogCur:=getAnalogCurrent(get2Bytes(bmsdata[0],bmsdata[1]));
003869  001390          meanValC:= 3*PackCurrent/4 + analogCur/4;
003870  001391          PackCurrent:=meanValC;
003871  001392        
003872  001393  //        BMSWrite(0x02, GETCOULOMBC);
003873  001394  //        bmsdata:=BMSRead8(0x02);
003874  001395        
003875  001396          // read cell voltage and temperature measurements
003876  001397          for (j:=0; j<numOfPacks;j++)
003877  001398              for (i:=0;i<numOfCells;i++)
003878  001399                  ad:= getBMSAd(i,j);
003879  001400                  // voltages
003880  001401                  BMSWrite(ad,GETCELLVOLT);
003881  001402                  bmsdata:=BMSRead2(ad);
003882  001403                  // current analog value
003883  001404                  analogV:=getAnalogVolt(get2Bytes(bmsdata[0],bmsdata[1]));
003884  001405                  // mean value from 80% of previous reading + 20% of current reading
003885  001406                  meanValV:= (4*packCellV[getCellNum(i,j)])/5 + analogV/5;
003886  001407                  packCellV[getCellNum(i,j)]:= meanValV;
003887  001408        
003888  001409                  // temperatures
003889  001410                  BMSWrite(ad,GETCELLTEMP);
003890  001411                  bmsdata:=BMSRead2(ad);
003891  001412                  analogT:=getAnalogTemp(get2Bytes(bmsdata[0],bmsdata[1]));
003892  001413                  meanValT:=(3*packCellT[getCellNum(i,j)])/4 + analogT/4;
003893  001414                  packCellT[getCellNum(i,j)]:=meanValT;
003894  001415        
003895  001416                  pause(10);
003896  001417              next
003897  001418          next
003898  001419      endif // if bmsconnection
003899  001420        
003900  001421  endfunc
003901  001422        
003902  001423        
003903  001424  //--SCREENS-----------------------------------------------------------------
003904  001425        
003905  001426  // Startup screen
003906  001427  func startUp()
003907  001428        
003908  001429      // StartUp2 1.0 generated 2/27/2013 8:50:10 PM
003909  001430      img_Show(hndl,iStartUp) ;
003910  001431        
003911  001432      // Statictext2 1.0 generated 2/27/2013 8:50:10 PM
003912  001433      img_Show(hndl,iStatictext2) ;
003913  001434        
003914  001435      // Statictext3 1.0 generated 2/27/2013 8:50:10 PM
003915  001436      img_Show(hndl,iStatictext3) ;
003916  001437        
003917  001438      // Image4 1.0 generated 2/27/2013 8:50:10 PM
003918  001439      img_Show(hndl,iImage1) ;
003919  001440        
003920  001441      // Statictext7 1.0 generated 2/27/2013 8:50:10 PM
003921  001442      img_Show(hndl,iStatictext7) ;
003922  001443        
003923  001444      // Statictext6 1.0 generated 2/27/2013 8:50:10 PM
003924  001445      img_Show(hndl,iStatictext6) ;
003925  001446        
003926  001447      // Statictext5 1.0 generated 2/27/2013 8:50:10 PM
003927  001448      img_Show(hndl,iStatictext5) ;
003928  001449        
003929  001450      // Statictext4 1.0 generated 2/27/2013 8:50:10 PM
003930  001451      img_Show(hndl,iStatictext4) ;
003931  001452        
003932  001453      return;
003933  001454  endfunc
003934  001455        
003935  001456  // Drive mode screen
003936  001457  func driveModeInit()
003937  001458        
003938  001459      var frame, state, numx;
003939  001460        
003940  001461      // DriveMode 1.0 generated 3/11/2013 9:57:04 PM
003941  001462        
003942  001463      // ResetTrip 1.0 generated 3/11/2013 9:58:48 PM
003943  001464      img_SetWord(hndl, iResetTrip, IMAGE_FLAGS, (img_GetWord(hndl, iResetTrip, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003944  001465      img_Show(hndl, iResetTrip);  // show button, only do this once
003945  001466      img_SetWord(hndl, iResetTrip, IMAGE_INDEX, state); // where state is 0 for up and 1 for down
003946  001467      img_Show(hndl,iResetTrip) ;
003947  001468        
003948  001469      // Image2 1.0 generated 3/11/2013 9:57:05 PM
003949  001470      img_Show(hndl,iImage2) ;
003950  001471        
003951  001472      // Image3 1.0 generated 3/11/2013 9:57:05 PM
003952  001473      img_Show(hndl,iImage3) ;
003953  001474        
003954  001475      // DriveLafLabel 1.0 generated 3/14/2013 5:47:24 PM
003955  001476      img_Show(hndl,iDriveLafLabel) ;
003956  001477        
003957  001478      // DriveModeLabel 1.0 generated 3/14/2013 5:47:21 PM
003958  001479      img_Show(hndl,iDriveModeLabel) ;
003959  001480        
003960  001481      // TurnOffLabel 1.0 generated 3/11/2013 9:57:05 PM
003961  001482     // img_Show(hndl,iTurnOffLabel) ;
003962  001483        
003963  001484      // DriveBMSMenu 1.0 generated 3/11/2013 9:57:05 PM
003964  001485      img_SetWord(hndl, iDriveBMSMenu, IMAGE_FLAGS, (img_GetWord(hndl, iDriveBMSMenu, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
003965  001486      img_SetWord(hndl, iDriveBMSMenu, IMAGE_INDEX, state); // where state is 0 for up and 1 for down
003966  001487      img_Show(hndl,iDriveBMSMenu) ;
003967  001488        
003968  001489      // SpeedLabel 1.0 generated 3/14/2013 5:46:07 PM
003969  001490      img_Show(hndl,iSpeedLabel) ;
003970  001491        
003971  001492      // DriveBMSLabel 1.0 generated 3/14/2013 5:46:13 PM
003972  001493      img_Show(hndl,iDriveBMSLabel) ;
003973  001494        
003974  001495      // DriveMPHLabel 1.0 generated 3/14/2013 5:50:01 PM
003975  001496      img_Show(hndl,iDriveMPHLabel) ;
003976  001497        
003977  001498      // OdometerLabel 1.0 generated 3/14/2013 5:46:14 PM
003978  001499      img_Show(hndl,iOdometerLabel) ;
003979  001500        
003980  001501      // Drive%label 1.0 generated 3/14/2013 5:49:15 PM
003981  001502      img_Show(hndl,iDrivePercLabel) ;
003982  001503        
003983  001504      // DriveAmpLabel 1.0 generated 3/14/2013 5:49:34 PM
003984  001505      img_Show(hndl,iDriveAmpLabel) ;
003985  001506        
003986  001507      img_Show(hndl, iSpeedValue);  // show all digits at 0, only do this once
003987  001508        
003988  001509      // BatLevelLED 1.0 generated 4/26/2013 3:23:24 PM
003989  001510      img_Show(hndl, iBatLevelLED);  // show all digits at 0, only do this once
003990  001511        
003991  001512      // PackCurrentLED 1.0 generated 4/26/2013 3:23:34 PM
003992  001513      img_Show(hndl, iPackCurrentLED);  // show all digits at 0, only do this once
003993  001514        
003994  001515      img_Show(hndl, iOdometerVal);  // show all digits at 0, only do this once
003995  001516        
003996  001517      img_Show(hndl, iTemperature);
003997  001518        
003998  001519        
003999  001520      // mileLabel 1.0 generated 5/6/2013 10:50:41 PM
004000  001521      img_Show(hndl,imileLabel) ;
004001  001522        
004002  001523  endfunc
004003  001524        
004004  001525  // screen for Diagnostic mode
004005  001526  func diagnosticModeInit()
004006  001527        
004007  001528  var state, numx ;
004008  001529  state :=1;
004009  001530        
004010  001531      // DiagnosticMode 1.0 generated 3/8/2013 2:14:57 AM
004011  001532        
004012  001533      // MainMenuLabel 1.0 generated 3/14/2013 4:43:51 PM
004013  001534      img_Show(hndl,iMainMenuLabel) ;
004014  001535        
004015  001536      // PleaseEnsureLabel 1.0 generated 3/14/2013 4:44:02 PM
004016  001537      img_Show(hndl,iPleaseEnsureLabel) ;
004017  001538        
004018  001539      // SafetyLoopLabel 1.0 generated 3/14/2013 3:05:09 PM
004019  001540      img_Show(hndl,iSafetyLoopLabel) ;
004020  001541        
004021  001542      // BMSLabel 1.0 generated 3/14/2013 4:45:24 PM
004022  001543      img_Show(hndl,iBMSLabel) ;
004023  001544        
004024  001545      // MotorLabel 1.0 generated 3/14/2013 4:45:30 PM
004025  001546      img_Show(hndl,iMotorLabel) ;
004026  001547        
004027  001548      // DiagnosticTitle 1.0 generated 3/8/2013 2:14:57 AM
004028  001549      img_Show(hndl,iDiagnosticTitle) ;
004029  001550        
004030  001551      // LafDiaLab 1.0 generated 3/8/2013 2:14:58 AM
004031  001552      img_Show(hndl,iLafDiaLab) ;
004032  001553        
004033  001554      // TeamInfoButton 1.0 generated 3/8/2013 2:14:58 AM
004034  001555      img_SetWord(hndl, iTeamInfoButton, IMAGE_FLAGS, (img_GetWord(hndl, iTeamInfoButton, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
004035  001556      img_Show(hndl, iTeamInfoButton);  // show button, only do this once
004036  001557      img_SetWord(hndl, iTeamInfoButton, IMAGE_INDEX, state); // where state is 0 for up and 1 for down
004037  001558      img_Show(hndl,iTeamInfoButton) ;
004038  001559        
004039  001560  endfunc
004040  001561        
004041  001562  // Screen for BMS menu
004042  001563  func BMSMenuInit()
004043  001564        
004044  001565      var state, numx;
004045  001566      // BMSMenu 1.0 generated 3/8/2013 2:13:21 AM
004046  001567        
004047  001568      // Statictext11 1.0 generated 3/8/2013 2:13:21 AM
004048  001569      img_Show(hndl,iStatictext11) ;
004049  001570        
004050  001571      // Statictext12 1.0 generated 3/8/2013 2:13:21 AM
004051  001572      img_Show(hndl,iStatictext12) ;
004052  001573        
004053  001574      // Pack1Button 1.0 generated 3/8/2013 2:13:21 AM
004054  001575      img_SetWord(hndl, iPack1Button, IMAGE_FLAGS, (img_GetWord(hndl, iPack1Button, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
004055  001576          // img_Show(hndl, iPack1Button);  // show button, only do this once
004056  001577      img_SetWord(hndl, iPack1Button, IMAGE_INDEX, state); // where state is 0 for up and 1 for down
004057  001578      img_Show(hndl,iPack1Button) ;
004058  001579        
004059  001580      // Statictext13 1.0 generated 3/8/2013 2:13:21 AM
004060  001581      img_Show(hndl,iStatictext13) ;
004061  001582        
004062  001583        
004063  001584        
004064  001585      // Statictext15 1.0 generated 3/8/2013 2:13:21 AM
004065  001586      img_Show(hndl,iStatictext15) ;
004066  001587        
004067  001588      // Statictext16 1.0 generated 3/8/2013 2:13:21 AM
004068  001589      img_Show(hndl,iStatictext16) ;
004069  001590        
004070  001591      // Statictext41 1.0 generated 3/8/2013 2:13:21 AM
004071  001592      img_Show(hndl,iStatictext41) ;
004072  001593        
004073  001594      // Statictext42 1.0 generated 3/8/2013 2:13:21 AM
004074  001595      img_Show(hndl,iStatictext42) ;
004075  001596        
004076  001597      // PackCurrent 1.0 generated 3/14/2013 5:16:11 PM
004077  001598      img_Show(hndl, iPackCurrent);  // show all digits at 0, only do this once
004078  001599        
004079  001600      // BMSMenuSOC 1.0 generated 3/14/2013 5:16:13 PM
004080  001601      img_Show(hndl, iBMSMenuSOC);  // show all digits at 0, only do this once
004081  001602        
004082  001603  endfunc
004083  001604        
004084  001605  // screen for Pack 1 Data
004085  001606  func BMSPack1Init()
004086  001607      var state, numx;
004087  001608      state:=1;
004088  001609      numx:=123;
004089  001610        
004090  001611      if(numOfCells>=1)
004091  001612          // Pack1Cell1V 1.0 generated 3/14/2013 5:12:42 PM
004092  001613          img_Show(hndl, iPack1Cell1V);  // show all digits at 0, only do this once
004093  001614          // Pack1Cell1Temp 1.0 generated 3/14/2013 5:12:54 PM
004094  001615          img_Show(hndl, iPack1Cell1Temp);  // show all digits at 0, only do this once
004095  001616      endif
004096  001617        
004097  001618      if(numOfCells>=2)
004098  001619          // Pack1Cell2V 1.0 generated 3/14/2013 5:12:50 PM
004099  001620          img_Show(hndl, iPack1Cell2V);  // show all digits at 0, only do this once
004100  001621          // Pack1Cell2Temp 1.0 generated 3/14/2013 5:12:56 PM
004101  001622          img_Show(hndl, iPack1Cell2Temp);  // show all digits at 0, only do this once
004102  001623      endif
004103  001624        
004104  001625      if(numOfCells>=3)
004105  001626          // Pack1Cell3V 1.0 generated 3/14/2013 5:12:52 PM
004106  001627          img_Show(hndl, iPack1Cell3V);  // show all digits at 0, only do this once
004107  001628          // Pack1Cell3Temp 1.0 generated 3/14/2013 5:12:58 PM
004108  001629          img_Show(hndl, iPack1Cell3Temp);  // show all digits at 0, only do this once
004109  001630      endif
004110  001631        
004111  001632      if(numOfCells>=4)
004112  001633          // Pack1Cell4V 1.0 generated 3/14/2013 5:12:53 PM
004113  001634          img_Show(hndl, iPack1Cell4V);  // show all digits at 0, only do this once
004114  001635          // Pack1Cell4Temp 1.0 generated 3/14/2013 5:13:00 PM
004115  001636          img_Show(hndl, iPack1Cell4Temp);  // show all digits at 0, only do this once
004116  001637      endif
004117  001638        
004118  001639      if(numOfCells>=5)
004119  001640          // Pack1Cell4V 1.0 generated 3/14/2013 5:12:53 PM
004120  001641          img_Show(hndl, iPack1Cell5V);  // show all digits at 0, only do this once
004121  001642          // Pack1Cell4Temp 1.0 generated 3/14/2013 5:13:00 PM
004122  001643          img_Show(hndl, iPack1Cell5Temp);  // show all digits at 0, only do this once
004123  001644      endif
004124  001645        
004125  001646      if(numOfCells>=6)
004126  001647          // Pack1Cell4V 1.0 generated 3/14/2013 5:12:53 PM
004127  001648          img_Show(hndl, iPack1Cell6V);  // show all digits at 0, only do this once
004128  001649          // Pack1Cell4Temp 1.0 generated 3/14/2013 5:13:00 PM
004129  001650          img_Show(hndl, iPack1Cell6Temp);  // show all digits at 0, only do this once
004130  001651      endif
004131  001652        
004132  001653      if(numOfCells>=7)
004133  001654          // Pack1Cell4V 1.0 generated 3/14/2013 5:12:53 PM
004134  001655          img_Show(hndl, iPack1Cell7V);  // show all digits at 0, only do this once
004135  001656          // Pack1Cell4Temp 1.0 generated 3/14/2013 5:13:00 PM
004136  001657          img_Show(hndl, iPack1Cell7Temp);  // show all digits at 0, only do this once
004137  001658      endif
004138  001659        
004139  001660      if(numOfCells==8)
004140  001661          // Pack1Cell4V 1.0 generated 3/14/2013 5:12:53 PM
004141  001662          img_Show(hndl, iPack1Cell8V);  // show all digits at 0, only do this once
004142  001663          // Pack1Cell4Temp 1.0 generated 3/14/2013 5:13:00 PM
004143  001664          img_Show(hndl, iPack1Cell8Temp);  // show all digits at 0, only do this once
004144  001665      endif
004145  001666        
004146  001667      // Pack1Current 1.0 generated 3/14/2013 5:13:03 PM
004147  001668      img_Show(hndl, iPack1Current);  // show all digits at 0, only do this once
004148  001669        
004149  001670      // Pack1SOC 1.0 generated 3/14/2013 5:14:31 PM
004150  001671      img_Show(hndl, iPack1SOC);  // show all digits at 0, only do this once
004151  001672        
004152  001673      // pack1dataheader1 1.0 generated 3/11/2013 3:37:28 PM
004153  001674      img_Show(hndl,ipack1dataheader1) ;
004154  001675        
004155  001676      // pack1laf 1.0 generated 3/11/2013 3:37:28 PM
004156  001677      img_Show(hndl,ipack1laf) ;
004157  001678        
004158  001679      // pack1dataheader2 1.0 generated 3/11/2013 3:37:28 PM
004159  001680      img_Show(hndl,ipack1dataheader2) ;
004160  001681        
004161  001682      // voltlabel1 1.0 generated 3/11/2013 3:37:28 PM
004162  001683      img_Show(hndl,ivoltlabel1) ;
004163  001684        
004164  001685      // templabel1 1.0 generated 3/11/2013 3:37:28 PM
004165  001686      img_Show(hndl,itemplabel1) ;
004166  001687        
004167  001688      // Pack1BMSMenu 1.0 generated 3/11/2013 3:37:29 PM
004168  001689      img_SetWord(hndl, iPack1BMSMenu, IMAGE_FLAGS, (img_GetWord(hndl, iPack1BMSMenu, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
004169  001690      img_SetWord(hndl, iPack1BMSMenu, IMAGE_INDEX, state); // where state is 0 for up and 1 for down
004170  001691      img_Show(hndl,iPack1BMSMenu) ;
004171  001692        
004172  001693      // Statictext40 1.0 generated 3/11/2013 3:37:29 PM
004173  001694      img_Show(hndl,iStatictext40) ;
004174  001695        
004175  001696      // Statictext43 1.0 generated 3/11/2013 3:37:29 PM
004176  001697      img_Show(hndl,iStatictext43) ;
004177  001698        
004178  001699  endfunc
004179  001700        
004180  001701  func motorControlInit()
004181  001702        
004182  001703      var state:=1;
004183  001704      // MotorControl 1.0 generated 3/1/2013 1:44:43 AM
004184  001705        
004185  001706      // Statictext17 1.0 generated 3/1/2013 1:44:43 AM
004186  001707      img_Show(hndl,iStatictext17) ;
004187  001708        
004188  001709      // Statictext18 1.0 generated 3/1/2013 1:44:43 AM
004189  001710      img_Show(hndl,iStatictext18) ;
004190  001711        
004191  001712      // Statictext19 1.0 generated 3/1/2013 1:44:43 AM
004192  001713      img_Show(hndl,iStatictext19) ;
004193  001714        
004194  001715        
004195  001716      // MCMainMenuButton 1.0 generated 3/1/2013 2:10:00 AM
004196  001717      img_SetWord(hndl, iMCMainMenuButton, IMAGE_FLAGS, (img_GetWord(hndl, iMCMainMenuButton, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
004197  001718      img_Show(hndl, iMCMainMenuButton);  // show button, only do this once
004198  001719      img_SetWord(hndl, iMCMainMenuButton, IMAGE_INDEX, state); // where state is 0 for up and 1 for down
004199  001720      img_Show(hndl,iMCMainMenuButton) ;
004200  001721        
004201  001722  endfunc
004202  001723        
004203  001724  func errorScreenInit()
004204  001725        
004205  001726      // ErrorScreen 1.0 generated 4/24/2013 1:31:13 AM
004206  001727        
004207  001728      // errlabel1 1.0 generated 4/24/2013 1:31:13 AM
004208  001729      img_Show(hndl,ierrlabel1) ;
004209  001730        
004210  001731      // errlabel2 1.0 generated 4/24/2013 1:31:13 AM
004211  001732      img_Show(hndl,ierrlabel2) ;
004212  001733        
004213  001734      // fiveSecLabel 1.0 generated 4/24/2013 1:31:13 AM
004214  001735      //img_Show(hndl,ifiveSecLabel) ;
004215  001736        
004216  001737      // safetyLabel 1.0 generated 4/24/2013 1:31:13 AM
004217  001738      img_Show(hndl,isafetyLabel) ;
004218  001739        
004219  001740      // bmsLabel 1.0 generated 4/24/2013 1:31:13 AM
004220  001741      img_Show(hndl,ibmsLedLabel) ;
004221  001742        
004222  001743      // motorLabel 1.0 generated 4/24/2013 1:31:13 AM
004223  001744      img_Show(hndl,imotorLedLabel) ;
004224  001745        
004225  001746      // curLabel 1.0 generated 4/24/2013 1:31:13 AM
004226  001747      img_Show(hndl,icurLabel) ;
004227  001748        
004228  001749      // tempLabel 1.0 generated 4/24/2013 1:31:13 AM
004229  001750      img_Show(hndl,itempLabel) ;
004230  001751        
004231  001752      // Statictext29 1.0 generated 4/24/2013 1:31:13 AM
004232  001753      img_Show(hndl,ivoltLabel) ;
004233  001754        
004234  001755      // ErrorBackToMain 1.0 generated 4/24/2013 1:31:13 AM
004235  001756      img_SetWord(hndl, iErrorBackToMain, IMAGE_FLAGS, (img_GetWord(hndl, iErrorBackToMain, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
004236  001757      img_SetWord(hndl, iErrorBackToMain, IMAGE_INDEX, 1); // where state is 0 for up and 1 for down
004237  001758      img_Show(hndl,iErrorBackToMain) ;
004238  001759        
004239  001760        
004240  001761  endfunc
004241  001762        
004242  001763  // page for team information
004243  001764  func teamInfoPage()
004244  001765        
004245  001766      var state;
004246  001767      state :=1;
004247  001768        
004248  001769      // TeamInfoPage 1.0 generated 3/1/2013 2:42:33 AM
004249  001770        
004250  001771      // Statictext21 1.0 generated 3/1/2013 2:42:33 AM
004251  001772      img_Show(hndl,iStatictext21) ;
004252  001773        
004253  001774      // Statictext22 1.0 generated 3/1/2013 2:42:33 AM
004254  001775      img_Show(hndl,iStatictext22) ;
004255  001776        
004256  001777      // Statictext33 1.0 generated 3/1/2013 2:42:33 AM
004257  001778      img_Show(hndl,iStatictext33) ;
004258  001779        
004259  001780      // Statictext34 1.0 generated 3/1/2013 2:42:33 AM
004260  001781      img_Show(hndl,iStatictext34) ;
004261  001782        
004262  001783      // Statictext35 1.0 generated 3/1/2013 2:42:33 AM
004263  001784      img_Show(hndl,iStatictext35) ;
004264  001785        
004265  001786      // Statictext36 1.0 generated 3/1/2013 2:42:33 AM
004266  001787      img_Show(hndl,iStatictext36) ;
004267  001788        
004268  001789      // TeamInfoPageMainMenu 1.0 generated 3/1/2013 2:42:33 AM
004269  001790      img_SetWord(hndl, iTeamInfoPageMainMenu, IMAGE_FLAGS, (img_GetWord(hndl, iTeamInfoPageMainMenu, IMAGE_FLAGS) | I_STAYONTOP) & ~I_TOUCH_DISABLE); // set to enable touch, only need to do this once
004270  001791      img_Show(hndl, iTeamInfoPageMainMenu);  // show button, only do this once
004271  001792      img_SetWord(hndl, iTeamInfoPageMainMenu, IMAGE_INDEX, state); // where state is 0 for up and 1 for down
004272  001793      img_Show(hndl,iTeamInfoPageMainMenu) ;
004273  001794        
004274  001795  endfunc
004275  001796        
004276  001797        
004277  001798  // MAIN FUNCTION -------------------------------------------
004278  001799  func main()
004279  001800      //var hstrings ; // Handle to access uSD strings, uncomment if required
004280  001801      //var hFontx ;   // Handle to access uSD fonts, uncomment if required and change n to font number
004281  001802      //var frame, numx;
004282  001803        
004283  001804      mode:= DIAGNOSTIC;
004284  001805      modeChange := 1;
004285  001806        
004286  001807  //    setbaud(BAUD_9600);
004287  001808      I2C_Open(57600);
004288  001809        
004289  001810      // set IO
004290  001811      pin_Set(INPUT, SAFETYLOOPIN);
004291  001812      pin_Set(INPUT, SPEEDPOT);
004292  001813      pin_Set(OUTPUT, LCIR);
004293  001814      pin_Set(OUTPUT, SAFETYLOOPCTRL);
004294  001815      pin_Set(OUTPUT, I2CPOWER);
004295  001816      pin_HI(I2CPOWER);
004296  001817      pin_HI(LCIR); // ACTIVE LOW SIGNAL
004297  001818      pin_LO(SAFETYLOOPCTRL);
004298  001819        
004299  001820      initScreenSetup();
004300  001821      systemConfig(); // configure system with variables e.g. #cells per pack etc
004301  001822        
004302  001823      // reset arrays
004303  001824      var i,j, cellNum;
004304  001825      for(j:=0;j<numOfPacks;j++)
004305  001826          for(i:=0;i<numOfPacks;i++)
004306  001827              cellNum:=getCellNum(i,j);
004307  001828              packCellV[cellNum]:=0;
004308  001829              packCellT[cellNum]:=0;
004309  001830          next
004310  001831      next
004311  001832        
004312  001833        
004313  001834      // create data logging d
004314  001835      dataHndl:=file_Open(dataFile,'w');
004315  001836      file_Close(dataHndl);
004316  001837        
004317  001838      SOC:=100;
004318  001839        
004319  001840      startUp();
004320  001841      pause(3000);
004321  001842        
004322  001843      repeat
004323  001844          getBMSData();
004324  001845          checkSpeed();
004325  001846          errorCheck();
004326  001847          processTouch();
004327  001848          changeDisplayMode();
004328  001849          updateDisplay();
004329  001850          //logData();
004330  001851      forever
004331  001852        
004332  001853  endfunc
004333  001854        
004334  001855  // for testing purposes
004335  001856  func threeBMS()
004336  001857      var *test;
004337  001858      var ad, cx1,cx2,cx3;
004338  001859      ad:=0x02;
004339  001860      BMSWrite(ad,0x15);
004340  001861      test:=BMSRead(ad,2);
004341  001862        
004342  001863      if(get2Bytes(test[0],test[1])==ad)
004343  001864          cx1:=1;
004344  001865      else
004345  001866          cx1:=0;
004346  001867      endif
004347  001868      pause(10);
004348  001869        
004349  001870      ad:=0x04;
004350  001871      BMSWrite(ad,0x15);
004351  001872      test:=BMSRead(ad,2);
004352  001873        
004353  001874      if(get2Bytes(test[0],test[1])==ad)
004354  001875          cx2:=1;
004355  001876      else
004356  001877          cx2:=0;
004357  001878      endif
004358  001879      pause(10);
004359  001880        
004360  001881        
004361  001882      ad:=0x06;
004362  001883      BMSWrite(ad,0x15);
004363  001884      test:=BMSRead(ad,2);
004364  001885        
004365  001886      if(get2Bytes(test[0],test[1])==ad)
004366  001887          cx3:=1;
004367  001888      else
004368  001889          cx3:=0;
004369  001890      endif
004370  001891        
004371  001892      pause(10);
004372  001893        
004373  001894      if(cx1 && cx2 && cx3)
004374  001895          BMSConnection:=1;
004375  001896      else
004376  001897          BMSConnection:=0;
004377  001898      endif
004378  001899        
004379  001900  endfunc
004380  001901        
004381  001902  // for testing
004382  001903  func oneCellBMS()
004383  001904        
004384  001905      var *bmsdata;
004385  001906      var ad, analogV, meanValV, meanValT, analogT;
004386  001907      ad:=0x02;
004387  001908      BMSWrite(ad,0x15);
004388  001909      bmsdata:=BMSRead2(ad);
004389  001910        
004390  001911      if(get2Bytes(bmsdata[0],bmsdata[1])==ad)
004391  001912          BMSConnection:=1;
004392  001913      else
004393  001914          BMSConnection:=0;
004394  001915      endif
004395  001916        
004396  001917      BMSWrite(ad,GETCELLVOLT);
004397  001918      bmsdata:=BMSRead2(ad);
004398  001919      // current analog value
004399  001920      analogV:=getAnalogVolt(get2Bytes(bmsdata[0],bmsdata[1]));
004400  001921      // mean value from 80% of previous reading + 20% of current reading
004401  001922      meanValV:= (3*packCellV[getCellNum(1,0)])/4 + analogV/4;
004402  001923      packCellV[getCellNum(0,0)]:= meanValV;
004403  001924        
004404  001925      // temperatures
004405  001926      BMSWrite(ad,GETCELLTEMP);
004406  001927      bmsdata:=BMSRead2(ad);
004407  001928      analogT:=getAnalogTemp(get2Bytes(bmsdata[0],bmsdata[1]));
004408  001929      meanValT:=(3*packCellT[getCellNum(1,0)])/4 + analogT/4;
004409  001930      packCellT[getCellNum(0,0)]:=meanValT;
004410  001931        
004411  001932      var meanCur, acur;
004412  001933      BMSWrite(ad, GETPACKCUR);
004413  001934      bmsdata:=BMSRead2(ad);
004414  001935      acur:=getAnalogCurrent(get2Bytes(bmsdata[0],bmsdata[1]));
004415  001936      PackCurrent:=3*PackCurrent/4 + acur/4;
004416  001937        
004417  001938        
004418  001939      BMSWrite(ad, 0x1A);
004419  001940      bmsdata:=BMSRead8(ad);
004420  001941        
004421  001942      if(BMSConnection)
004422  001943      putstr(" cur:");
004423  001944      putnum(DEC, PackCurrent);
004424  001945        
004425  001946      putstr(" cc:");
004426  001947      putnum(HEX, get2Bytes(bmsdata[0],bmsdata[1]));
004427  001948      putnum(HEX, get2Bytes(bmsdata[2],bmsdata[3]));
004428  001949      putstr(" ");
004429  001950      endif
004430  001951     // pause(100);
004431  001952  endfunc
004432  001953        
004433  001954  // testing
004434  001955  func twoCellTemp()
004435  001956        
004436  001957      var *test;
004437  001958      var ad, cx2,cx3;
004438  001959      ad:=0x04;
004439  001960      BMSWrite(ad,0x15);
004440  001961      test:=BMSRead2(ad);
004441  001962        
004442  001963      if(get2Bytes(test[0],test[1])==ad)
004443  001964          cx2:=1;
004444  001965      else
004445  001966          cx2:=0;
004446  001967      endif
004447  001968        
004448  001969      ad:=0x06;
004449  001970      BMSWrite(ad,0x15);
004450  001971      test:=BMSRead(ad,2);
004451  001972        
004452  001973      if(get2Bytes(test[0],test[1])==ad)
004453  001974          cx3:=1;
004454  001975      else
004455  001976          cx3:=0;
004456  001977      endif
004457  001978        
004458  001979      pause(10);
004459  001980        
004460  001981      if(cx2 && cx3)
004461  001982          BMSConnection:=1;
004462  001983      else
004463  001984          BMSConnection:=0;
004464  001985      endif
004465  001986      var *bmsdata;
004466  001987      // temperatures
004467  001988      BMSWrite(0x04,GETCELLTEMP);
004468  001989      bmsdata:=BMSRead2(0x04);
004469  001990      packCellT[getCellNum(1,0)]:=getAnalogTemp(get2Bytes(bmsdata[0],bmsdata[1]));
004470  001991        
004471  001992      BMSWrite(0x06,GETCELLTEMP);
004472  001993      bmsdata:=BMSRead2(0x06);
004473  001994      packCellT[getCellNum(2,0)]:=getAnalogTemp(get2Bytes(bmsdata[0],bmsdata[1]));
004474  001995        
004475  001996  endfunc
004476  001997        
Notice: no execution path to func 'twoCellTemp'
Notice: no execution path to func 'oneCellBMS'
Notice: local var 'meanCur' in func 'oneCellBMS' is never used (line 1932 file:ScadaDisplay.4dg)
Notice: no execution path to func 'threeBMS'
Notice: local var 'numx' in func 'BMSMenuInit' is never used (line 1565 file:ScadaDisplay.4dg)
Notice: local var 'numx' in func 'diagnosticModeInit' is never used (line 1528 file:ScadaDisplay.4dg)
Notice: local var 'numx' in func 'driveModeInit' is never used (line 1459 file:ScadaDisplay.4dg)
Notice: local var 'frame' in func 'driveModeInit' is never used (line 1459 file:ScadaDisplay.4dg)
Notice: local var 'adp' in func 'getBMSData' is never used (line 1354 file:ScadaDisplay.4dg)
Notice: no execution path to func 'logData'
Notice: local var 'string' in func 'logData' is never used (line 1342 file:ScadaDisplay.4dg)
Notice: no execution path to func 'checkConnections'
Notice: no execution path to func 'serialCommands'
Notice: no execution path to func 'println'
Notice: no execution path to func 'BMSRead4'


Symbol Table:
name                 decimal    hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                           7  0x00000007 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (not used)
BACKLITE                               6  0x00000006 (const dword)  (not used)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (not used)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BMSConnection                         18  0x00000012 (mem) word (global)  (usage 50)
BMSCONNECTION                          1  0x00000001 (const dword)  (not used)
BMSMAINDRIVE                           9  0x00000009 (const dword)  (not used)
BMSMENU                                3  0x00000003 (const dword)  (usage 24)
BMSMenuInit                         1439  0x0000059f (User func) args[0] r=0  (usage 3)
BMSPACK1                               4  0x00000004 (const dword)  (usage 18)
BMSPack1Init                        1054  0x0000041e (User func) args[0] r=0  (usage 3)
BMSPACK2                              11  0x0000000b (const dword)  (not used)
BMSPACK3                              12  0x0000000c (const dword)  (not used)
BMSPACK4                              13  0x0000000d (const dword)  (not used)
BMSRead                           UNRESOLVED  (usage 6)
BMSRead2                            6994  0x00001b52 (User func) args[1] r=0  (usage 26)
BMSRead4                          UNRESOLVED (User func) args[1] r=0  (not used)
BMSRead8                            7080  0x00001ba8 (User func) args[1] r=0  (usage 2)
BMSWrite                            7320  0x00001c98 (User func) args[2] r=0  (usage 42)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
BUS_0                                  8  0x00000008 (const dword)  (not used)
BUS_1                                  9  0x00000009 (const dword)  (not used)
BUS_2                                 10  0x0000000a (const dword)  (not used)
BUS_3                                 11  0x0000000b (const dword)  (not used)
BUS_4                                 12  0x0000000c (const dword)  (not used)
BUS_5                                 13  0x0000000d (const dword)  (not used)
BUS_6                                 14  0x0000000e (const dword)  (not used)
BUS_7                                 15  0x0000000f (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             5  0x00000005 (const dword)  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (usage 3)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
CELLNUM                                5  0x00000005 (const dword)  (not used)
cellNum                               46  0x0000002e (mem) word (global)  (usage 4)
CELLTEMP                               7  0x00000007 (const dword)  (not used)
cellTemp                              50  0x00000032 (mem) word (global)  (usage 1)
CELLVOLT                               6  0x00000006 (const dword)  (not used)
cellVolt                              48  0x00000030 (mem) word (global)  (usage 1)
changeDisplayMode                   5319  0x000014c7 (User func) args[0] r=0  (usage 3)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
checkConnections                  UNRESOLVED (User func) args[0] r=0  (not used)
CHECKSERIAL                            0  0x00000000 (const dword)  (not used)
checkSpeed                          2626  0x00000a42 (User func) args[0] r=0  (usage 3)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (not used)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (not used)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (not used)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (not used)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
configFile                             6  0x00000006 (mem) word (global)  (usage 4)
configHndl                             4  0x00000004 (mem) word (global)  (usage 6)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
coulCountBase                         62  0x0000003e (mem) word (global)  (usage 1)
coulCountIn                           60  0x0000003c (mem) word (global)  (usage 1)
COULOMBCOUNT                          11  0x0000000b (const dword)  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
curSafe                              214  0x000000d6 (mem) word (global)  (usage 13)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
dataFile                               8  0x00000008 (mem) word (global)  (usage 8)
dataHndl                              10  0x0000000a (mem) word (global)  (usage 16)
DEC                                 1290  0x0000050a (const dword)  (usage 2)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
decFromChar                         7405  0x00001ced (User func) args[3] r=0  (usage 15)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIAGNOSTIC                             1  0x00000001 (const dword)  (usage 45)
diagnosticError                       40  0x00000028 (mem) word (global)  (usage 1)
diagnosticModeInit                  1588  0x00000634 (User func) args[0] r=0  (usage 3)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
disk                                   0  0x00000000 (mem) word (global)  (usage 6)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[2] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DISPLAY_PAGE                          33  0x00000021 (const dword)  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DOWN                                   0  0x00000000 (const dword)  (not used)
driveModeInit                       1733  0x000006c5 (User func) args[0] r=0  (usage 3)
DRIVING                                2  0x00000002 (const dword)  (usage 24)
DSK                                63490  0x0000f802 (const dword)  (not used)
dumSpeed                              56  0x00000038 (mem) word (global)  (usage 10)
ENABLE                                 1  0x00000001 (const dword)  (not used)
ERROR                                 14  0x0000000e (const dword)  (usage 21)
error0                                36  0x00000024 (mem) word (global)  (usage 13)
error1                                38  0x00000026 (mem) word (global)  (usage 13)
errorCheck                          6170  0x0000181a (User func) args[0] r=0  (usage 3)
ERRORMOVING                            6  0x00000006 (const dword)  (not used)
errorScreenInit                      810  0x0000032a (User func) args[0] r=0  (usage 3)
ERRORSTAT                              5  0x00000005 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (usage 7)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (usage 3)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (not used)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (usage 3)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (not used)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (usage 10)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (usage 2)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -157  0xffffff63 (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
get2Bytes                           6888  0x00001ae8 (User func) args[2] r=0  (usage 38)
GETADDRESS                            21  0x00000015 (const dword)  (usage 9)
getAnalogCurrent                    6728  0x00001a48 (User func) args[1] r=0  (usage 5)
getAnalogTemp                       6751  0x00001a5f (User func) args[1] r=0  (usage 9)
getAnalogVolt                       6765  0x00001a6d (User func) args[1] r=0  (usage 5)
getBMSAd                            6974  0x00001b3e (User func) args[2] r=0  (usage 6)
getBMSData                          2101  0x00000835 (User func) args[0] r=0  (usage 3)
getCellNum                          6905  0x00001af9 (User func) args[2] r=0  (usage 33)
GETCELLTEMP                           17  0x00000011 (const dword)  (usage 9)
GETCELLVOLT                           16  0x00000010 (const dword)  (usage 5)
GETCELLVT                             27  0x0000001b (const dword)  (not used)
GETCOULOMBC                           26  0x0000001a (const dword)  (not used)
getMaxTemp                          6781  0x00001a7d (User func) args[0] r=0  (usage 9)
GETPACKCUR                            19  0x00000013 (const dword)  (usage 5)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (usage 54)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (not used)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (not used)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 9)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (not used)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (not used)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (not used)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (not used)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (not used)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (usage 3)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (usage 3)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (usage 4)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   2  0x00000002 (mem) word (global)  (usage 690)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
I2C                                63520  0x0000f820 (const dword)  (not used)
I2C_Ack                             -169  0xffffff57 (PmmC func) args[0] r=0  (usage 30)
I2C_AckPoll                         -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C_AckStatus                       -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C_Close                           -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_Getn                            -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C_Gets                            -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C_Idle                            -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_Nack                            -170  0xffffff56 (PmmC func) args[0] r=0  (usage 8)
I2C_Open                            -162  0xffffff5e (PmmC func) args[1] r=0  (usage 3)
I2C_Putn                            -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C_Puts                            -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C_Read                            -167  0xffffff59 (PmmC func) args[0] r=1  (usage 38)
I2C_Restart                         -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2C_SPEED                          57600  0x0000e100 (const dword)  (not used)
I2C_Start                           -164  0xffffff5c (PmmC func) args[0] r=1  (usage 11)
I2C_Stop                            -165  0xffffff5b (PmmC func) args[0] r=1  (usage 11)
I2C_Write                           -168  0xffffff58 (PmmC func) args[1] r=1  (usage 20)
I2CPOWER                               5  0x00000005 (const dword)  (usage 6)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (not used)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 78)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 78)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
iBatLevelLED                          20  0x00000014 (const ??? 0)  (usage 6)
iBMSBackToMain                       112  0x00000070 (const ??? 0)  (usage 18)
iBMSLabel                             35  0x00000023 (const ??? 0)  (usage 3)
ibmsLedLabel                         142  0x0000008e (const ??? 0)  (usage 3)
iBMSMenuButton1                       29  0x0000001d (const ??? 0)  (usage 18)
iBMSMenuDisconnect                    37  0x00000025 (const ??? 0)  (usage 12)
iBMSMenuSOC                          117  0x00000075 (const ??? 0)  (usage 6)
iBMSToDriveMenu                      119  0x00000077 (const ??? 0)  (usage 18)
iCantDrive                            33  0x00000021 (const ??? 0)  (usage 12)
iCantTurnOff                          17  0x00000011 (const ??? 0)  (usage 12)
iCantTurnOffLabel                     18  0x00000012 (const ??? 0)  (usage 12)
icellLabel5                           84  0x00000054 (const ??? 0)  (usage 3)
icellLabel6                           85  0x00000055 (const ??? 0)  (usage 3)
icellLabel7                           86  0x00000056 (const ??? 0)  (usage 3)
icellLabel8                           89  0x00000059 (const ??? 0)  (usage 3)
iclabel1                              80  0x00000050 (const ??? 0)  (usage 3)
iclabel2                              81  0x00000051 (const ??? 0)  (usage 3)
iclabel3                              82  0x00000052 (const ??? 0)  (usage 3)
iclabel4                              83  0x00000053 (const ??? 0)  (usage 3)
icurLabel                            139  0x0000008b (const ??? 0)  (usage 3)
iDiagnosticTitle                      25  0x00000019 (const ??? 0)  (usage 3)
iDriveAmpLabel                        15  0x0000000f (const ??? 0)  (usage 3)
iDriveBMSLabel                        14  0x0000000e (const ??? 0)  (usage 3)
iDriveBMSMenu                         16  0x00000010 (const ??? 0)  (usage 18)
iDriveLafLabel                        13  0x0000000d (const ??? 0)  (usage 3)
iDriveModeLabel                       12  0x0000000c (const ??? 0)  (usage 3)
iDriveMPHLabel                         7  0x00000007 (const ??? 0)  (usage 3)
iDrivePercLabel                        8  0x00000008 (const ??? 0)  (usage 3)
ierrlabel1                           134  0x00000086 (const ??? 0)  (usage 3)
ierrlabel2                           135  0x00000087 (const ??? 0)  (usage 3)
iErrorBackToMain                     136  0x00000088 (const ??? 0)  (usage 18)
iiBatLevelLED                         21  0x00000015 (const ??? 0)  (not used)
iiBMSMenuSOC                         118  0x00000076 (const ??? 0)  (not used)
iImage1                               46  0x0000002e (const ??? 0)  (usage 3)
iImage2                               10  0x0000000a (const ??? 0)  (usage 3)
iImage3                               11  0x0000000b (const ??? 0)  (usage 3)
iiOdometerVal                          6  0x00000006 (const ??? 0)  (not used)
iiPack1Cell1Temp                      67  0x00000043 (const ??? 0)  (not used)
iiPack1Cell1V                         53  0x00000035 (const ??? 0)  (not used)
iiPack1Cell2Temp                      69  0x00000045 (const ??? 0)  (not used)
iiPack1Cell2V                         55  0x00000037 (const ??? 0)  (not used)
iiPack1Cell3Temp                      71  0x00000047 (const ??? 0)  (not used)
iiPack1Cell3V                         57  0x00000039 (const ??? 0)  (not used)
iiPack1Cell4Temp                      73  0x00000049 (const ??? 0)  (not used)
iiPack1Cell4V                         59  0x0000003b (const ??? 0)  (not used)
iiPack1Cell5Temp                      75  0x0000004b (const ??? 0)  (not used)
iiPack1Cell5V                         65  0x00000041 (const ??? 0)  (not used)
iiPack1Cell6Temp                      77  0x0000004d (const ??? 0)  (not used)
iiPack1Cell6V                         61  0x0000003d (const ??? 0)  (not used)
iiPack1Cell7Temp                      79  0x0000004f (const ??? 0)  (not used)
iiPack1Cell7V                         63  0x0000003f (const ??? 0)  (not used)
iiPack1Cell8Temp                      93  0x0000005d (const ??? 0)  (not used)
iiPack1Cell8V                         91  0x0000005b (const ??? 0)  (not used)
iiPack1Current                        98  0x00000062 (const ??? 0)  (not used)
iiPack1SOC                           101  0x00000065 (const ??? 0)  (not used)
iiPackCurrent                        116  0x00000074 (const ??? 0)  (not used)
iiPackCurrentLED                      23  0x00000017 (const ??? 0)  (not used)
iiSpeedValue                           4  0x00000004 (const ??? 0)  (not used)
iLafDiaLab                            27  0x0000001b (const ??? 0)  (usage 3)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (usage 156)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 84)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (not used)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (usage 3)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
iMainMenuLabel                        31  0x0000001f (const ??? 0)  (usage 3)
iMCButton                             26  0x0000001a (const ??? 0)  (usage 18)
iMCMainMenuButton                    126  0x0000007e (const ??? 0)  (usage 21)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (not used)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (usage 6)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 78)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (usage 3)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (not used)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 165)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 384)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 45)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
imileLabel                            24  0x00000018 (const ??? 0)  (usage 3)
iMotorContDisconnect                  38  0x00000026 (const ??? 0)  (usage 12)
iMotorLabel                           36  0x00000024 (const ??? 0)  (usage 3)
imotorLedLabel                       143  0x0000008f (const ??? 0)  (usage 3)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
initScreenSetup                     6554  0x0000199a (User func) args[0] r=0  (usage 3)
iNoPack2B                            120  0x00000078 (const ??? 0)  (usage 12)
iNoPack3B                            121  0x00000079 (const ??? 0)  (usage 12)
iNoPack4B                            122  0x0000007a (const ??? 0)  (usage 12)
INPUT                                  1  0x00000001 (const dword)  (usage 6)
INVERSE                               64  0x00000040 (const dword)  (not used)
INVRHALF                              32  0x00000020 (mem) word (global)  (usage 4)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
iOdometerLabel                         2  0x00000002 (const ??? 0)  (usage 3)
iOdometerVal                           5  0x00000005 (const ??? 0)  (usage 6)
iPack1BackToMain                      87  0x00000057 (const ??? 0)  (usage 18)
iPack1BMSMenu                         88  0x00000058 (const ??? 0)  (usage 18)
iPack1Button                         105  0x00000069 (const ??? 0)  (usage 18)
iPack1Cell1Temp                       66  0x00000042 (const ??? 0)  (usage 6)
iPack1Cell1V                          52  0x00000034 (const ??? 0)  (usage 6)
iPack1Cell2Temp                       68  0x00000044 (const ??? 0)  (usage 6)
iPack1Cell2V                          54  0x00000036 (const ??? 0)  (usage 6)
iPack1Cell3Temp                       70  0x00000046 (const ??? 0)  (usage 6)
iPack1Cell3V                          56  0x00000038 (const ??? 0)  (usage 6)
iPack1Cell4Temp                       72  0x00000048 (const ??? 0)  (usage 6)
iPack1Cell4V                          58  0x0000003a (const ??? 0)  (usage 6)
iPack1Cell5Temp                       74  0x0000004a (const ??? 0)  (usage 6)
iPack1Cell5V                          64  0x00000040 (const ??? 0)  (usage 6)
iPack1Cell6Temp                       76  0x0000004c (const ??? 0)  (usage 6)
iPack1Cell6V                          60  0x0000003c (const ??? 0)  (usage 6)
iPack1Cell7Temp                       78  0x0000004e (const ??? 0)  (usage 6)
iPack1Cell7V                          62  0x0000003e (const ??? 0)  (usage 6)
iPack1Cell8Temp                       92  0x0000005c (const ??? 0)  (usage 6)
iPack1Cell8V                          90  0x0000005a (const ??? 0)  (usage 6)
iPack1Current                         97  0x00000061 (const ??? 0)  (usage 6)
ipack1dataheader1                     47  0x0000002f (const ??? 0)  (usage 3)
ipack1dataheader2                     49  0x00000031 (const ??? 0)  (usage 3)
ipack1laf                             48  0x00000030 (const ??? 0)  (usage 3)
iPack1SOC                            100  0x00000064 (const ??? 0)  (usage 6)
iPack2Button                         107  0x0000006b (const ??? 0)  (usage 12)
iPack3Button                         108  0x0000006c (const ??? 0)  (usage 12)
iPack4Button                         109  0x0000006d (const ??? 0)  (usage 12)
iPackCurrent                         115  0x00000073 (const ??? 0)  (usage 6)
iPackCurrentLED                       22  0x00000016 (const ??? 0)  (usage 6)
iPackToDriveMenu                     102  0x00000066 (const ??? 0)  (usage 18)
iPleaseEnsureLabel                    30  0x0000001e (const ??? 0)  (usage 3)
iReadyToDrive                         28  0x0000001c (const ??? 0)  (usage 21)
iResetTrip                             9  0x00000009 (const ??? 0)  (usage 21)
isafetyLabel                         137  0x00000089 (const ??? 0)  (usage 3)
iSafetyLoopLabel                      34  0x00000022 (const ??? 0)  (usage 3)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
iSlowDown                            138  0x0000008a (const ??? 0)  (usage 12)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
iSpeedLabel                            1  0x00000001 (const ??? 0)  (usage 3)
iSpeedValue                            3  0x00000003 (const ??? 0)  (usage 6)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStartUp                              39  0x00000027 (const ??? 0)  (usage 3)
iStatictext11                        103  0x00000067 (const ??? 0)  (usage 3)
iStatictext12                        104  0x00000068 (const ??? 0)  (usage 3)
iStatictext13                        106  0x0000006a (const ??? 0)  (usage 3)
iStatictext15                        110  0x0000006e (const ??? 0)  (usage 3)
iStatictext16                        111  0x0000006f (const ??? 0)  (usage 3)
iStatictext17                        123  0x0000007b (const ??? 0)  (usage 3)
iStatictext18                        124  0x0000007c (const ??? 0)  (usage 3)
iStatictext19                        125  0x0000007d (const ??? 0)  (usage 3)
iStatictext2                          40  0x00000028 (const ??? 0)  (usage 3)
iStatictext21                        127  0x0000007f (const ??? 0)  (usage 3)
iStatictext22                        128  0x00000080 (const ??? 0)  (usage 3)
iStatictext3                          41  0x00000029 (const ??? 0)  (usage 3)
iStatictext33                        129  0x00000081 (const ??? 0)  (usage 3)
iStatictext34                        130  0x00000082 (const ??? 0)  (usage 3)
iStatictext35                        131  0x00000083 (const ??? 0)  (usage 3)
iStatictext36                        132  0x00000084 (const ??? 0)  (usage 3)
iStatictext4                          42  0x0000002a (const ??? 0)  (usage 3)
iStatictext40                         96  0x00000060 (const ??? 0)  (usage 3)
iStatictext41                        113  0x00000071 (const ??? 0)  (usage 3)
iStatictext42                        114  0x00000072 (const ??? 0)  (usage 3)
iStatictext43                         99  0x00000063 (const ??? 0)  (usage 3)
iStatictext5                          43  0x0000002b (const ??? 0)  (usage 3)
iStatictext6                          44  0x0000002c (const ??? 0)  (usage 3)
iStatictext7                          45  0x0000002d (const ??? 0)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iTeamInfoButton                       32  0x00000020 (const ??? 0)  (usage 21)
iTeamInfoPageMainMenu                133  0x00000085 (const ??? 0)  (usage 15)
iTemperature                          19  0x00000013 (const ??? 0)  (usage 9)
itempLabel                           140  0x0000008c (const ??? 0)  (usage 3)
itemplabel1                           51  0x00000033 (const ??? 0)  (usage 3)
itemplabel2                           95  0x0000005f (const ??? 0)  (usage 3)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iTurnOffDrive                          0  0x00000000 (const ??? 0)  (usage 18)
ivoltLabel                           141  0x0000008d (const ??? 0)  (usage 3)
ivoltlabel1                           50  0x00000032 (const ??? 0)  (usage 3)
ivoltlabel2                           94  0x0000005e (const ??? 0)  (usage 3)
IVORY                              65534  0x0000fffe (const dword)  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LC_ON                                 24  0x00000018 (mem) word (global)  (usage 40)
LCIR                                   3  0x00000003 (const dword)  (usage 15)
ledDigitsDisplay                    7429  0x00001d05 (User func) args[7] r=0  (usage 72)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (usage 27)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
logData                           UNRESOLVED (User func) args[0] r=0  (not used)
lowerTemp                            208  0x000000d0 (mem) word (global)  (usage 7)
lowerVolt                            202  0x000000ca (mem) word (global)  (usage 7)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                 395  0x0000018b (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                       93  0x0000005d (const dword)  (not used)
MEDIA_SECTOR_LO                       92  0x0000005c (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINSPEED                               1  0x00000001 (const dword)  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
mode                                  42  0x0000002a (mem) word (global)  (usage 150)
modeChange                            44  0x0000002c (mem) word (global)  (usage 66)
MOTORCONT                              7  0x00000007 (const dword)  (usage 9)
MotorContConnection                   20  0x00000014 (mem) word (global)  (usage 12)
motorControlInit                     949  0x000003b5 (User func) args[0] r=0  (usage 3)
movingState                           34  0x00000022 (mem) word (global)  (usage 22)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
numOfCells                            68  0x00000044 (mem) word (global)  (usage 67)
NUMOFCELLS                             9  0x00000009 (const dword)  (not used)
numOfPacks                            66  0x00000042 (mem) word (global)  (usage 34)
NUMOFPACKS                             8  0x00000008 (const dword)  (not used)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
OdometerVal                           52  0x00000034 (mem) word (global)  (usage 10)
OFF                                    0  0x00000000 (const dword)  (not used)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (usage 3)
oneCellBMS                        UNRESOLVED (User func) args[0] r=0  (not used)
OPAMPGAIN                             30  0x0000001e (mem) word (global)  (usage 4)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (usage 9)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (not used)
packCellT                             70  0x00000046 (mem) word[32] (global)  (usage 47)
packCellV                            134  0x00000086 (mem) word[32] (global)  (usage 43)
PackCurrent                           58  0x0000003a (mem) word (global)  (usage 25)
packNum                               64  0x00000040 (mem) word (global)  (usage 1)
PACKNUM                                3  0x00000003 (const dword)  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 96)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PICASO                                 1  0x00000001 (const dword)  (usage 3)
PICASO_FUNCTIONS                       0  0x00000000 (const ??? 0)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (usage 15)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (usage 15)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (usage 8)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (usage 15)
PINK                               65049  0x0000fe19 (const dword)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
println                           UNRESOLVED (User func) args[1] r=0  (not used)
processTouch                        5456  0x00001550 (User func) args[0] r=0  (usage 3)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (usage 6)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 15)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_PAGE                             34  0x00000022 (const dword)  (not used)
ReadyToDrive                          12  0x0000000c (mem) word (global)  (usage 17)
RED                                63488  0x0000f800 (const dword)  (usage 27)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SAFETYLOOP                             2  0x00000002 (const dword)  (not used)
SAFETYLOOPCTRL                         1  0x00000001 (const dword)  (usage 18)
SAFETYLOOPIN                           2  0x00000002 (const dword)  (usage 8)
SafetyLoopOut                         16  0x00000010 (mem) word (global)  (usage 1)
SafetyLoopState                       14  0x0000000e (mem) word (global)  (usage 18)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (usage 3)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
serialCommands                    UNRESOLVED (User func) args[0] r=0  (not used)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (not used)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (not used)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOC                                   54  0x00000036 (mem) word (global)  (usage 13)
SOLID                                  0  0x00000000 (const dword)  (not used)
SPEED                                 10  0x0000000a (const dword)  (not used)
speed                                198  0x000000c6 (mem) word (global)  (usage 13)
SPEEDPOT                               4  0x00000004 (const dword)  (usage 6)
speedReset                           218  0x000000da (mem) word (global)  (usage 1)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
SSD1963_ENTER_IDLE_MODE               57  0x00000039 (const dword)  (not used)
SSD1963_ENTER_INVERT_MODE             33  0x00000021 (const dword)  (not used)
SSD1963_ENTER_NORMAL_MODE             19  0x00000013 (const dword)  (not used)
SSD1963_ENTER_PARTIAL_MODE            18  0x00000012 (const dword)  (not used)
SSD1963_ENTER_SLEEP_MODE              16  0x00000010 (const dword)  (not used)
SSD1963_EXIT_IDLE_MODE                56  0x00000038 (const dword)  (not used)
SSD1963_EXIT_INVERT_MODE              32  0x00000020 (const dword)  (not used)
SSD1963_EXIT_SLEEP_MODE               17  0x00000011 (const dword)  (not used)
SSD1963_GET_ADDRESS_MODE              11  0x0000000b (const dword)  (not used)
SSD1963_GET_DBC_CONF                 209  0x000000d1 (const dword)  (not used)
SSD1963_GET_DBC_TH                   213  0x000000d5 (const dword)  (not used)
SSD1963_GET_DISPLAY_MODE              13  0x0000000d (const dword)  (not used)
SSD1963_GET_GPIO0_ROP                201  0x000000c9 (const dword)  (not used)
SSD1963_GET_GPIO1_ROP                203  0x000000cb (const dword)  (not used)
SSD1963_GET_GPIO2_ROP                205  0x000000cd (const dword)  (not used)
SSD1963_GET_GPIO3_ROP                207  0x000000cf (const dword)  (not used)
SSD1963_GET_GPIO_CONFIG              185  0x000000b9 (const dword)  (not used)
SSD1963_GET_GPIO_STATUS              187  0x000000bb (const dword)  (not used)
SSD1963_GET_HORZ_PERIOD              181  0x000000b5 (const dword)  (not used)
SSD1963_GET_LCD_GEN0                 192  0x000000c0 (const dword)  (not used)
SSD1963_GET_LCD_GEN1                 194  0x000000c2 (const dword)  (not used)
SSD1963_GET_LCD_GEN2                 196  0x000000c4 (const dword)  (not used)
SSD1963_GET_LCD_GEN3                 198  0x000000c6 (const dword)  (not used)
SSD1963_GET_LCD_MODE                 177  0x000000b1 (const dword)  (not used)
SSD1963_GET_LSHIFT_FREQ              231  0x000000e7 (const dword)  (not used)
SSD1963_GET_PIXEL_DATA_INTERFACE     241  0x000000f1 (const dword)  (not used)
SSD1963_GET_PLL_MN                   227  0x000000e3 (const dword)  (not used)
SSD1963_GET_PLL_STATUS               228  0x000000e4 (const dword)  (not used)
SSD1963_GET_POST_PROC                189  0x000000bd (const dword)  (not used)
SSD1963_GET_POWER_MODE                10  0x0000000a (const dword)  (not used)
SSD1963_GET_PWM_CONFIG               191  0x000000bf (const dword)  (not used)
SSD1963_GET_SCANLINE                  69  0x00000045 (const dword)  (not used)
SSD1963_GET_TEAR_EFFECT_STATUS        14  0x0000000e (const dword)  (not used)
SSD1963_GET_VERT_PERIOD              183  0x000000b7 (const dword)  (not used)
SSD1963_NOP                            0  0x00000000 (const dword)  (not used)
SSD1963_READ_DDB                     161  0x000000a1 (const dword)  (not used)
SSD1963_READ_MEMORY_CONTINUE          62  0x0000003e (const dword)  (not used)
SSD1963_READ_MEMORY_START             46  0x0000002e (const dword)  (not used)
SSD1963_SET_ADDRESS_MODE              54  0x00000036 (const dword)  (not used)
SSD1963_SET_COLUMN_ADDRESS            42  0x0000002a (const dword)  (not used)
SSD1963_SET_DBC_CONF                 208  0x000000d0 (const dword)  (not used)
SSD1963_SET_DBC_TH                   212  0x000000d4 (const dword)  (not used)
SSD1963_SET_DEEP_SLEEP               229  0x000000e5 (const dword)  (not used)
SSD1963_SET_DISPLAY_OFF               40  0x00000028 (const dword)  (not used)
SSD1963_SET_DISPLAY_ON                41  0x00000029 (const dword)  (not used)
SSD1963_SET_GAMMA_CURVE               38  0x00000026 (const dword)  (not used)
SSD1963_SET_GPIO0_ROP                200  0x000000c8 (const dword)  (not used)
SSD1963_SET_GPIO1_ROP                202  0x000000ca (const dword)  (not used)
SSD1963_SET_GPIO2_ROP                204  0x000000cc (const dword)  (not used)
SSD1963_SET_GPIO3_ROP                206  0x000000ce (const dword)  (not used)
SSD1963_SET_GPIO_CONFIG              184  0x000000b8 (const dword)  (not used)
SSD1963_SET_GPIO_VALUE               186  0x000000ba (const dword)  (not used)
SSD1963_SET_HORZ_PERIOD              180  0x000000b4 (const dword)  (not used)
SSD1963_SET_LCD_GEN0                 193  0x000000c1 (const dword)  (not used)
SSD1963_SET_LCD_GEN1                 195  0x000000c3 (const dword)  (not used)
SSD1963_SET_LCD_GEN2                 197  0x000000c5 (const dword)  (not used)
SSD1963_SET_LCD_GEN3                 199  0x000000c7 (const dword)  (not used)
SSD1963_SET_LCD_MODE                 176  0x000000b0 (const dword)  (not used)
SSD1963_SET_LSHIFT_FREQ              230  0x000000e6 (const dword)  (not used)
SSD1963_SET_PAGE_ADDRESS              43  0x0000002b (const dword)  (not used)
SSD1963_SET_PARTIAL_AREA              48  0x00000030 (const dword)  (not used)
SSD1963_SET_PLL                      224  0x000000e0 (const dword)  (not used)
SSD1963_SET_PLL_MN                   226  0x000000e2 (const dword)  (not used)
SSD1963_SET_POST_PROC                188  0x000000bc (const dword)  (not used)
SSD1963_SET_PWM_CONFIG               190  0x000000be (const dword)  (not used)
SSD1963_SET_REAR_ON                   53  0x00000035 (const dword)  (not used)
SSD1963_SET_SCROLL_AREA               51  0x00000033 (const dword)  (not used)
SSD1963_SET_SCROLL_START              55  0x00000037 (const dword)  (not used)
SSD1963_SET_TEAR_OFF                  52  0x00000034 (const dword)  (not used)
SSD1963_SET_TEAR_SCANLINE             68  0x00000044 (const dword)  (not used)
SSD1963_SET_VERT_PERIOD              182  0x000000b6 (const dword)  (not used)
SSD1963_SOFT_RESET                     1  0x00000001 (const dword)  (not used)
SSD1963_WRITE_MEMORY_CONTINUE         60  0x0000003c (const dword)  (not used)
SSD1963_WRITE_MEMORY_START            44  0x0000002c (const dword)  (not used)
startUp                             2020  0x000007e4 (User func) args[0] r=0  (usage 3)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (usage 2)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
subSystemBool                         22  0x00000016 (mem) word (global)  (usage 14)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (not used)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
systemConfig                        2683  0x00000a7b (User func) args[0] r=0  (usage 3)
systemVarSafe                        216  0x000000d8 (mem) word (global)  (usage 16)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEAMINFO                               8  0x00000008 (const dword)  (usage 9)
teamInfoPage                         675  0x000002a3 (User func) args[0] r=0  (usage 3)
tempSafe                             212  0x000000d4 (mem) word (global)  (usage 13)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
threeBMS                          UNRESOLVED (User func) args[0] r=0  (not used)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_DRIVE                           78  0x0000004e (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 3)
TOUCH_GETX                             1  0x00000001 (const dword)  (not used)
TOUCH_GETY                             2  0x00000002 (const dword)  (not used)
TOUCH_MOVING                           3  0x00000003 (const dword)  (not used)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 3)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (not used)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
twoCellTemp                       UNRESOLVED (User func) args[0] r=0  (not used)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (not used)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (not used)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (not used)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
U:\ece_scratch\LFEV-ESCM\SCADA 2013\Touchscreen_Code\ScadaDisplay.4dg    2709  0x00000a95 (const ??? 0)  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (not used)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
uLCD_43PT_GFX2                         0  0x00000000 (const ??? 0)  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
updateDisplay                       2804  0x00000af4 (User func) args[0] r=0  (usage 3)
upperCurrent                         204  0x000000cc (mem) word (global)  (usage 7)
upperTemp                            206  0x000000ce (mem) word (global)  (usage 7)
upperVolt                            200  0x000000c8 (mem) word (global)  (usage 7)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
voltSafe                             210  0x000000d2 (mem) word (global)  (usage 13)
VVMAX                                 28  0x0000001c (mem) word (global)  (usage 4)
VVREF                                 26  0x0000001a (mem) word (global)  (usage 10)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (not used)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
WRITE_PAGE                            35  0x00000023 (const dword)  (not used)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
